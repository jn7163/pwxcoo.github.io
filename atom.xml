<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PWXCOO</title>
  
  <subtitle>内部整修</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.pwxcoo.com/"/>
  <updated>2019-02-07T13:49:14.806Z</updated>
  <id>https://blog.pwxcoo.com/</id>
  
  <author>
    <name>pwxcoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《阿里巴巴Java开发手册》注意点</title>
    <link href="https://blog.pwxcoo.com/2019/01/23/%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E3%80%8B%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>https://blog.pwxcoo.com/2019/01/23/《阿里巴巴Java开发手册》注意点/</id>
    <published>2019-01-23T08:21:10.000Z</published>
    <updated>2019-02-07T13:49:14.806Z</updated>
    
    <content type="html"><![CDATA[<p>大概把这本书里之前没注意到的整理了一下。</p><h2 id="prerequisites"><a href="#prerequisites" class="headerlink" title="prerequisites"></a>prerequisites</h2><ul><li>POJO: plain ordinary java object<ul><li>PO: persistent object</li><li>BO: business object</li><li>VO: value/view object</li><li>DTO: data Transfer object </li><li>DAO: data access object</li></ul></li></ul><h2 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h2><h3 id="（一）命名风格"><a href="#（一）命名风格" class="headerlink" title="（一）命名风格"></a>（一）命名风格</h3><ul><li>抽象类命名使用 Abstract 或 Base 开头 ;</li><li>POJO 类中布尔类型的变量，都不要加 is 前缀 ，否则部分框架解析会引起序列化错误。</li><li>枚举类名建议带上 Enum 后缀</li></ul><h3 id="（二）常量定义"><a href="#（二）常量定义" class="headerlink" title="（二）常量定义"></a>（二）常量定义</h3><ul><li>在 long 或者 Long 赋值时，数值后使用大写的 L ，不能是小写的 l ，小写容易跟数字 1 混淆，造成误解。</li></ul><h3 id="（三）代码格式"><a href="#（三）代码格式" class="headerlink" title="（三）代码格式"></a>（三）代码格式</h3><ul><li>采用 4 个空格缩进，禁止使用 tab 字符。</li></ul><h3 id="（四）OOP-规约"><a href="#（四）OOP-规约" class="headerlink" title="（四）OOP 规约"></a>（四）OOP 规约</h3><ul><li>Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用 equals 。推荐使用 java . util . Objects # equals(JDK 7 引入的工具类 )</li><li>关于基本数据类型与包装数据类型的使用标准如下: <ol><li>【强制】所有的 POJO 类属性必须使用包装数据类型。</li><li>【强制】 RPC 方法的返回值和参数必须使用包装数据类型。</li><li>【推荐】所有的局部变量使用基本数据类型。</li></ol></li><li>禁止在 POJO 类中，同时存在对应属性 xxx 的 isXxx() 和 getXxx() 方法。框架在调用属性 xxx 的提取方法时，并不能确定哪个方法一定是被优先调用到。</li><li><p>使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。（源码的实现会舍去末尾的空字符）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Construct result</span></span><br><span class="line"><span class="keyword">int</span> resultSize = list.size();</span><br><span class="line"><span class="keyword">if</span> (limit == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (resultSize &gt; <span class="number">0</span> &amp;&amp; list.get(resultSize - <span class="number">1</span>).length() == <span class="number">0</span>) &#123;</span><br><span class="line">        resultSize--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">String[] result = <span class="keyword">new</span> String[resultSize];</span><br><span class="line"><span class="keyword">return</span> list.subList(<span class="number">0</span>， resultSize).toArray(result);</span><br></pre></td></tr></table></figure></li><li><p>循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</p></li></ul><h3 id="（五）集合处理"><a href="#（五）集合处理" class="headerlink" title="（五）集合处理"></a>（五）集合处理</h3><ul><li>ArrayList 的 subList 结果不可强转成 ArrayList 。subList 返回的是 ArrayList 的内部类 SubList ，并不是 ArrayList 而是 ArrayList<br>的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。</li><li>使用集合转数组的方法，必须使用集合的 toArray(T[] array) ，传入的是类型完全一样的数组，大小就是 <code>list.size()</code> 。直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[] 类，若强转其它类型数组将出现 ClassCastException 错误。</li><li>使用工具类 Arrays . asList() 把数组转换成集合时，不能使用其修改集合相关的方法。sList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。 Arrays . asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</li><li>泛型通配符&lt;? extends T &gt;来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 &lt;? super T&gt; 不能使用 get 方法，作为接口调用赋值时易出错。扩展说一下 PECS(Producer Extends Consumer Super) 原则:第一、频繁往外读取内容的，适合用&lt;? extends T &gt;。第二、经常往里插入的，适合用 &lt;? super T&gt; 。</li><li>集合初始化时,指定集合初始值大小。</li><li>使用 entrySet 遍历 Map 类集合 KV ,而不是 keySet 方式进行遍历。</li><li>Map 类对 null 值的处理。</li></ul><blockquote><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>no</td><td>no</td><td>Dictionary</td><td>thread safe</td></tr><tr><td>ConcurrentHashMap</td><td>no</td><td>no</td><td>AbstractMap</td><td>锁分段（JDK8: CAS）</td></tr><tr><td>TreeMap</td><td>no</td><td>yes</td><td>AbstractMap</td><td>thread unsafe</td></tr><tr><td>HashMap</td><td>yes</td><td>yes</td><td>AbstractMap</td><td>thread unsafe</td></tr></tbody></table></blockquote><h3 id="（六）-并发处理"><a href="#（六）-并发处理" class="headerlink" title="（六） 并发处理"></a>（六） 并发处理</h3><ul><li>【强制】创建线程或线程池时请指定有意义的线程名称,方便出错时回溯。</li><li>【强制】线程池不允许使用 Executors 去创建,而是通过 ThreadPoolExecutor 的方式,这样的处理方式让写的同学更加明确线程池的运行规则,规避资源耗尽的风险。<ol><li>FixedThreadPool 和 SingleThreadPool :<br>允许的请求队列长度为 Integer.MAX_VALUE ,可能会堆积大量的请求,从而导致 OOM 。</li><li>CachedThreadPool 和 ScheduledThreadPool :<br>允许的创建线程数量为 Integer.MAX_VALUE ,可能会创建大量的线程,从而导致 OOM 。</li></ol></li><li>并发修改同一记录时,避免更新丢失,需要加锁。要么在应用层加锁,要么在缓存加锁,要么在数据库层使用乐观锁,使用 version 作为更新依据。如果每次访问冲突概率小于 20%,推荐使用乐观锁,否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</li><li>多线程并行处理定时任务时, Timer 运行多个 TimeTask 时,只要其中之一没有捕获抛出的异常,其它任务便会自动终止运行,使用 ScheduledExecutorService 则没有这个问题。</li><li>使用 CountDownLatch 进行异步转同步操作,每个线程退出前必须调用 countDown 方法,线程执行代码注意 catch 异常,确保 countDown 方法被执行到,避免主线程无法执行至 await 方法,直到超时才返回结果。</li><li>HashMap 在容量不够进行 resize 时由于高并发可能出现死链,导致 CPU 飙升, 在开发过程中可以使用其它数据结构或加锁来规避此风险。</li><li>ThreadLocal 无法解决共享对象的更新问题, ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共享的,所以设置为静态变量,所有此类实例共享此静态变量 ,也就是说在类第一次被使用时装载,只分配一块存储空间,所有此类的对象 ( 只要是这个线程内定义的 ) 都可以操控这个变量。</li></ul><h3 id="（七）控制语句"><a href="#（七）控制语句" class="headerlink" title="（七）控制语句"></a>（七）控制语句</h3><ul><li>【参考】下列情形,需要进行参数校验:<ol><li>调用频次低的方法。</li><li>执行时间开销很大的方法。此情形中,参数校验时间几乎可以忽略不计,但如果因为参<br>数错误导致中间执行回退,或者错误,那得不偿失。</li><li>需要极高稳定性和可用性的方法。</li><li>对外提供的开放接口,不管是 RPC / API / HTTP 接口。</li><li>敏感权限入口。</li></ol></li><li>【参考】下列情形,不需要进行参数校验:<ol><li>极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。</li><li>底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道,参数错误不太可能到底<br>层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中,部署在同一台服务器中,所<br>以 DAO 的参数校验,可以省略。</li><li>被声明成 private 只会被自己代码所调用的方法,如果能够确定调用方法的代码传入参<br>数已经做过检查或者肯定不会有问题,此时可以不校验参数。</li></ol></li></ul><h3 id="（八）-注释规约"><a href="#（八）-注释规约" class="headerlink" title="（八） 注释规约"></a>（八） 注释规约</h3><h3 id="（九）其它"><a href="#（九）其它" class="headerlink" title="（九）其它"></a>（九）其它</h3><ul><li>【强制】后台输送给页面的变量必须加 $!{var} ——中间的感叹号。</li><li>在 JDK 8 中, 针对统计时间等场景,推荐使用 Instant 类。</li></ul><h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h3 id="一-异常处理"><a href="#一-异常处理" class="headerlink" title="(一) 异常处理"></a>(一) 异常处理</h3><ul><li>【推荐】防止 NPE ,是程序员的基本修养,注意 NPE 产生的场景:<ol><li>返回类型为基本数据类型, return 包装数据类型的对象时,自动拆箱有可能产生 NPE 。</li><li>数据库的查询结果可能为 null 。</li><li>集合里的元素即使 isNotEmpty ,取出的数据元素也可能为 null 。</li><li>远程调用返回对象时,一律要求进行空指针判断,防止 NPE 。</li><li>对于 Session 中获取的数据,建议 NPE 检查,避免空指针。</li><li>级联调用 <code>obj.getA().getB().getC()</code>; 一连串调用,易产生 NPE 。</li></ol></li></ul><h3 id="二-日志规约"><a href="#二-日志规约" class="headerlink" title="(二) 日志规约"></a>(二) 日志规约</h3><ul><li>应用中不可直接使用日志系统 (Log 4 j 、 Logback) 中的 API ,而应依赖使用日志框架 SLF4J（Simple Logging Facade for Java）中的 API ,使用门面模式的日志框架,有利于维护和各个类的日志处理方式统一。</li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h2 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h2><ul><li>【强制】表单、 AJAX 提交必须执行 CSRF 安全验证。</li></ul><h2 id="MySQL-数据库"><a href="#MySQL-数据库" class="headerlink" title="MySQL 数据库"></a>MySQL 数据库</h2><h3 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h3><ul><li>【强制】表达是与否概念的字段,必须使用 is_xxx 的方式命名,数据类型是 unsigned tinyint(1 表示是,0 表示否)。</li><li>【强制】主键索引名为 pk_ 字段名;唯一索引名为 uk _字段名 ; 普通索引名则为 idx _字段名。</li><li>【强制】小数类型为 decimal ,禁止使用 float 和 double 。</li><li>【强制】如果存储的字符串长度几乎相等,使用 char 定长字符串类型。</li><li>【强制】表必备三字段: id , gmt _ create , gmt _ modified 。</li><li>【推荐】字段允许适当冗余,以提高查询性能,但必须考虑数据一致。冗余字段应遵循:<ol><li>不是频繁修改的字段。</li><li>不是 varchar 超长字段,更不能是 text 字段。</li></ol></li><li>【推荐】单表行数超过 500 万行或者单表容量超过 2 GB ,才推荐进行分库分表。</li></ul><h3 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二) 索引规约"></a>(二) 索引规约</h3><ul><li>【强制】业务上具有唯一特性的字段,即使是多个字段的组合,也必须建成唯一索引。</li><li>【强制】在 varchar 字段上建立索引时,必须指定索引长度,没必要对全字段建立索引,根据实际文本区分度决定索引长度即可。索引的长度与区分度是一对矛盾体,一般对字符串类型数据,长度为 20 的索引,区分度会高达 90% 以上,可以使用 count(distinct left( 列名, 索引长度 )) / count( * ) 的区分度来确定。</li><li>【强制】页面搜索严禁左模糊或者全模糊</li><li>【推荐】如果有 order by 的场景,请注意利用索引的有序性。</li><li>【推荐】利用覆盖索引来进行查询操作,避免回表。</li><li>【推荐】利用延迟关联或者子查询优化超多分页场景。</li><li>【推荐】建组合索引的时候,区分度最高的在最左边。</li></ul><h3 id="三-SQL-语句"><a href="#三-SQL-语句" class="headerlink" title="(三) SQL 语句"></a>(三) SQL 语句</h3><ul><li>【强制】不要使用 count( 列名 ) 或 count( 常量 ) 来替代 count( <em> ) , count( </em> ) 是 SQL 92 定义的标准统计行数的语法,跟数据库无关,跟 NULL 和非 NULL 无关。count( * ) 会统计值为 NULL 的行,而 count( 列名 ) 不会统计此列为 NULL 值的行。</li><li>【强制】 count(distinct col) 计算该列除 NULL 之外的不重复行数,注意 count(distinct col 1, col 2 ) 如果其中一列全为 NULL ,那么即使另一列有不同的值,也返回为 0。</li><li>【强制】当某一列的值全是 NULL 时, count(col) 的返回结果为 0,但 sum(col) 的返回结果为 NULL ,因此使用 sum() 时需注意 NPE 问题。</li><li>【强制】使用 ISNULL() 来判断是否为 NULL 值。NULL 与任何值的直接比较都为 NULL。</li><li>【强制】不得使用外键与级联,一切外键概念必须在应用层解决。</li></ul><h3 id="四-ORM-映射"><a href="#四-ORM-映射" class="headerlink" title="(四) ORM 映射"></a>(四) ORM 映射</h3><ul><li>【强制】 POJO 类的布尔属性不能加 is ,而数据库字段必须加 is _,要求在 resultMap 中进行字段与属性之间的映射。</li><li>【强制】不要用 resultClass 当返回参数,即使所有类属性名与数据库字段一一对应,也需要定义 ; 反过来,每一个表也必然有一个 POJO 类与之对应。</li><li>【强制】 sql. xml 配置参数使用: #{}, # param # 不要使用${} 此种方式容易出现 SQL 注入。</li><li>【参考】&lt; isEqual &gt;中的 compareValue 是与属性值对比的常量,一般是数字,表示相等时带上此条件 ; &lt; isNotEmpty &gt;表示不为空且不为 null 时执行 ; &lt; isNotNull &gt;表示不为 null 值时执行。</li></ul><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><h3 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h3><h3 id="二-二方库依赖"><a href="#二-二方库依赖" class="headerlink" title="(二) 二方库依赖"></a>(二) 二方库依赖</h3><ul><li>【强制】二方库里可以定义枚举类型,参数可以使用枚举类型,但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。</li></ul><h3 id="三-服务器"><a href="#三-服务器" class="headerlink" title="(三) 服务器"></a>(三) 服务器</h3><ul><li><p>【推荐】高并发服务器建议调小 TCP 协议的 time _ wait 超时时间。操作系统默认 240 秒。在 linux 服务器上请通过变更/ etc / sysctl . conf 文件去修改该缺省值 ( 秒 ) :</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure></li><li><p>【推荐】调大服务器所支持的最大文件句柄数 (File Descriptor ,简写为 fd) 。</p></li><li>【推荐】给 JVM 环境参数设置- XX :+ HeapDumpOnOutOfMemoryError 参数,让 JVM 碰到 OOM 场景时输出 dump 信息。</li><li>【推荐】在线上生产环境, JVM 的 Xms（JVM初始分配的堆内存 ） 和 Xmx（JVM最大允许分配的堆内存，按需分配 ） 设置一样大小的内存容量,避免在 GC 后调整堆大小带来的压力。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="java" scheme="https://blog.pwxcoo.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>linux notes</title>
    <link href="https://blog.pwxcoo.com/2018/12/28/linux-notes/"/>
    <id>https://blog.pwxcoo.com/2018/12/28/linux-notes/</id>
    <published>2018-12-28T08:30:58.000Z</published>
    <updated>2019-02-07T09:40:26.571Z</updated>
    
    <content type="html"><![CDATA[<p>a collection of frequently-used linux operations.</p><h2 id="server-configure-ssh-service"><a href="#server-configure-ssh-service" class="headerlink" title="server configure ssh service"></a>server configure ssh service</h2><ul><li><code>useradd -m [username]</code>, <code>-m</code> will automatically create new user folder in <code>/home</code></li><li><code>passwd [username]</code>, configure password</li><li><code>usermod -s /bin/bash [username]</code>, change default login shell<ul><li><code>cat /etc/passwd</code> list all users</li><li><code>cat /etc/shells</code> list all available shells</li></ul></li><li><code>usermod -aG sudo pwxcoo</code>，grant <code>sudo</code> privileges<ul><li><code>groups</code> check group of current user</li></ul></li><li>in client，<code>scp id_rsa.pub [username]@[server address]:/home/[username]</code> transfer public key to server</li><li>back to server，<code>mv id_rsa.pub .ssh/authorized_keys</code>  will be ok</li></ul><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><ul><li><code>sudo apt update</code></li><li><code>sudo apt install nginx</code></li><li><code>cd /etc/nginx/conf.d</code> (NGINX site-specific configuration files are kept in <code>/etc/nginx/conf.d</code>)</li><li><p>simple template. <code>example.com.conf</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  example.com;</span><br><span class="line"></span><br><span class="line">    #charset koi8-r;</span><br><span class="line">    #access_log  /var/log/nginx/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #error_page  404              /404.html;</span><br><span class="line"></span><br><span class="line">    # redirect server error pages to the static page /50x.html</span><br><span class="line">    #</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>test nginx configration is ok</p><ul><li><code>sudo nginx -t</code></li><li><code>sudo nginx -s reload</code></li></ul></li></ul><h2 id="set-environment-variables"><a href="#set-environment-variables" class="headerlink" title="set environment variables"></a>set environment variables</h2><p>linux will execute <code>/etc/profile</code> while booting up, this script will execute all script in <code>/etc/profile.d</code>, so add some scripts in <code>/etc/profile.d</code> will be easily maintained and convenient.</p><p>like <code>jdk.sh</code>, it will set environment variables for Java.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> J2SDKDIR=/usr/lib/jvm/java-8-oracle</span><br><span class="line"><span class="built_in">export</span> J2REDIR=/usr/lib/jvm/java-8-oracle/jre</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/lib/jvm/java-8-oracle/bin:/usr/lib/jvm/java-8-oracle/db/bin:/usr/lib/jvm/java-8-oracle/jre/bin</span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-oracle</span><br><span class="line"><span class="built_in">export</span> DERBY_HOME=/usr/lib/jvm/java-8-oracle/db</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="memo" scheme="https://blog.pwxcoo.com/tags/memo/"/>
    
      <category term="linux" scheme="https://blog.pwxcoo.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中格式化输出的format</title>
    <link href="https://blog.pwxcoo.com/2018/12/24/C-C-%E4%B8%AD%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%9A%84format/"/>
    <id>https://blog.pwxcoo.com/2018/12/24/C-C-中格式化输出的format/</id>
    <published>2018-12-24T10:26:04.000Z</published>
    <updated>2019-02-07T09:40:26.567Z</updated>
    
    <content type="html"><![CDATA[<p>就是 C 中 <code>printf()</code> 的 format 标签。</p><p>format 标签属性是 <code>%[flag][width][.precision][length]specifier</code></p><h2 id="specifier"><a href="#specifier" class="headerlink" title="specifier"></a>specifier</h2><ul><li><code>c</code>, 字符</li><li><code>d/i</code>，有符号十进制整数</li><li><code>e</code>，使用 e 字符的科学计数法</li><li><code>E</code>，使用 E 字符的科学计数法</li><li><code>f</code>，十进制浮点数</li><li><code>g</code>，自动选择 %e 或 %f 中合适的表示法</li><li><code>G</code>，自动选择 %E 或 %f 中合适的表示法</li><li><code>o</code>，有符号八进制</li><li><code>s</code>，字符的字符串</li><li><code>u</code>，无符号十进制整数</li><li><code>x</code>，无符号十六进制整数</li><li><code>X</code>，无符号十六进制整数（大写字母）</li><li><code>p</code>，指针地址</li><li><code>n</code>，无输出</li><li><code>%</code>，字符</li></ul><h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><ul><li><code>-</code>，给定宽度内左对齐（默认右对齐）</li><li><code>+</code>，强制在结果之前显示 +/-</li><li><code>(space)</code>，如果没有写入任何字符，则在该值前面插入一个空格</li><li><code>#</code>，<ul><li>如果和 o/x/X 使用，非零值前面会分别显示 0/0x/0X</li><li>如果和 e/E/f 使用，会强制输出包含一个小数点，即使后面没有数字也会显示小数点（默认情况下，如果后面没有数字的时候，不会显示小数点）</li><li>如果和 g/G 使用，结果与 e/E 相同，但是尾部的零不会被移除</li></ul></li><li><code>0</code>，在制定填充 padding 的数字的左边放置 0，而不是空格。</li></ul><h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><ul><li><code>(number)</code>，要输出字符的最小数目。如果输出的值小于该数，则被空格填充，如果长于，也不会被截断</li><li><code>*</code>，宽度在 format 字符串中为指定，但是会作为附加的整数值参数放置于将要被格式化的参数之前</li></ul><h2 id="precision"><a href="#precision" class="headerlink" title=".precision"></a>.precision</h2><ul><li><code>.number</code>，指定了写入的数字的最小位数<ul><li>e/E/f，在小数点后输出的小数位数</li><li>g/G，要输出的最大有效位数</li><li>s，要输出的最大字符数</li><li>c，no impact</li><li>未指定任何精度时，默认为 1。如果指定时不带一个显式值，则假定为 0</li></ul></li><li><code>.*</code>，同 width 中 <code>*</code></li></ul><h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><ul><li>h，参数被解释为短整型</li><li>l，参数被解释成长整型</li><li>L，参数被解释成长双精度型</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.runoob.com/cprogramming/c-function-vprintf.html" target="_blank" rel="noopener">C 库函数 - vprintf()</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="c" scheme="https://blog.pwxcoo.com/tags/c/"/>
    
      <category term="c++" scheme="https://blog.pwxcoo.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>a collection of common operations in vim</title>
    <link href="https://blog.pwxcoo.com/2018/12/14/a-collection-of-common-operations-in-vim/"/>
    <id>https://blog.pwxcoo.com/2018/12/14/a-collection-of-common-operations-in-vim/</id>
    <published>2018-12-14T08:44:25.000Z</published>
    <updated>2019-02-07T09:40:26.567Z</updated>
    
    <content type="html"><![CDATA[<p>自己使用 Vim 中的一些常见问题。</p><p>我的 vimrc: <a href="https://github.com/pwxcoo/vimrc" target="_blank" rel="noopener">pwxcoo/vimrc</a></p><h2 id="Update-vim-on-ubuntu"><a href="#Update-vim-on-ubuntu" class="headerlink" title="Update vim on ubuntu"></a>Update vim on ubuntu</h2><p><a href="https://vi.stackexchange.com/questions/10817/how-can-i-get-a-newer-version-of-vim-on-ubuntu" target="_blank" rel="noopener">How can I get a newer version of Vim on Ubuntu</a></p><ul><li><code>sudo add-apt-repository ppa:jonathonf/vim</code></li><li><code>sudo apt update</code></li><li><code>sudo apt install vim</code></li></ul><h2 id="Use-System-Clipboard"><a href="#Use-System-Clipboard" class="headerlink" title="Use System Clipboard"></a>Use System Clipboard</h2><ul><li><code>sudo apt install vim-gnome</code></li><li><code>vim --version | grep &quot;clipboard&quot;</code> 查看 clipboard 前面是否是 <code>+</code></li></ul><p>然后</p><ul><li><code>&quot;+y</code> 复制到系统剪切板</li><li><code>&quot;+p</code> 粘贴</li></ul><h2 id="replace-one-by-one"><a href="#replace-one-by-one" class="headerlink" title="replace one by one"></a>replace one by one</h2><p><a href="https://blog.csdn.net/feelang/article/details/38408875" target="_blank" rel="noopener">Vim -&gt; 边确认边查找替换</a></p><ul><li><code>/{which}</code> 开始查找</li><li><code>cw {what} [ESC]</code> 删除并替换</li><li><code>n</code> 下一个单词</li><li><code>.</code> 重复上一个操作 (删除并替换) </li></ul><h2 id="operate-multiple-rows"><a href="#operate-multiple-rows" class="headerlink" title="operate multiple rows"></a>operate multiple rows</h2><p>块操作</p><ul><li><code>C-v</code> 开始块操作</li><li><code>C-d</code> 向下移动</li><li>操作<ul><li><code>shift + i</code> 插入</li><li><code>J</code> 连结所有行 (Join) </li><li><code>&gt;</code> / <code>&lt;</code> 左右缩进</li><li><code>=</code> 自动缩进</li></ul></li><li><code>[ESC]</code> 生效</li></ul><h2 id="Plugins-keyboard-shortcut"><a href="#Plugins-keyboard-shortcut" class="headerlink" title="Plugins keyboard shortcut"></a>Plugins keyboard shortcut</h2><h3 id="NERDTree"><a href="#NERDTree" class="headerlink" title="NERDTree"></a>NERDTree</h3><ul><li><code>shift + i</code> 显示隐藏文件</li><li><code>m</code> 一系列操作<ul><li><code>a</code> 创造新文件</li></ul></li></ul><h3 id="Tabbar"><a href="#Tabbar" class="headerlink" title="Tabbar"></a>Tabbar</h3><ul><li><code>:bd</code> 关闭 buffer  (<strong>Recommend</strong>)</li><li><code>:bw</code> 关闭并不保存</li></ul><h3 id="NERDCommenter"><a href="#NERDCommenter" class="headerlink" title="NERDCommenter"></a>NERDCommenter</h3><ul><li><code>&lt;leader&gt; + c + &lt;space&gt;</code> 快速注释</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="memo" scheme="https://blog.pwxcoo.com/tags/memo/"/>
    
      <category term="linux" scheme="https://blog.pwxcoo.com/tags/linux/"/>
    
      <category term="vim" scheme="https://blog.pwxcoo.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>makefile和常见gcc参数</title>
    <link href="https://blog.pwxcoo.com/2018/12/07/makefile%E5%92%8C%E5%B8%B8%E8%A7%81gcc%E5%8F%82%E6%95%B0/"/>
    <id>https://blog.pwxcoo.com/2018/12/07/makefile和常见gcc参数/</id>
    <published>2018-12-07T11:40:59.000Z</published>
    <updated>2019-02-07T09:40:26.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><p>makefile 的大概规则模板: </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target ... : prerequisites ...</span><br><span class="line">command</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>好，就是上面这种样子。讲完了。</p><hr><p><strong>makefile 的原理就是根据 target 文件和 prerequisites 文件修改时间的值来确定 target 文件是否需要重新编译。</strong></p><p>而且 prerequisites 也有 prerequisites’s prerequisites 的。makefile 文件首先去寻找 prerequisites，如果没有继续递归寻找，过程有点像堆栈的过程，编译的过程有点像拓扑排序的一个过程。</p><p>但是 makefile 有一些 tricks 的，所以经常看到一些复杂工程文件的 makefile 很大。</p><p>然后有些可以提一下常用的一些东西。</p><ul><li><code>\</code> 用来换行</li><li>makefile 中使用变量，用 <code>$(variable)</code> 就可以用了</li><li><p><code>.PHONY</code> 指明某个 label 是伪目标文件，防止 makefile 中定义的目标和实际工作目录下的实际文件名出现冲突</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure></li><li><p><code>$@</code> 表示目标文件，<code>$^</code> 表示全部依赖，<code>$&lt;</code> 表示第一个依赖。</p></li></ul><p>一个最简单的 makefile 例子: </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CXX = g++</span><br><span class="line">CFLAGS= --std=c++11</span><br><span class="line">SOURCE = lexer.cpp</span><br><span class="line">DEPS = lexer.h</span><br><span class="line">TARGET = lexer</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(SOURCE)</span> <span class="variable">$(DEPS)</span></span><br><span class="line"><span class="variable">$(CXX)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$(SOURCE)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line">strip <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>复杂的话，github 上有很多 makefile 的模板。</p><h2 id="GCC参数"><a href="#GCC参数" class="headerlink" title="GCC参数"></a>GCC参数</h2><ul><li><code>x</code> 指明使用语言的参数<ul><li>‘c’, ‘objective-c’, ‘c-header’, ‘c++’, ‘cpp-output’, ‘assembler’, ‘assembler-with-cpp’</li></ul></li><li><code>c</code> 预处理，编译，汇编 =&gt; obj 文件</li><li><code>S</code> 预处理和编译 =&gt; 汇编代码</li><li><p><code>E</code> 预处理，不生成文件，需要重定向到一个文件里</p>  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c &gt; pianoapan.txt </span><br><span class="line">gcc -E hello.c | more</span><br></pre></td></tr></table></figure></li><li><p><code>o</code> 编译成可执行文件</p></li><li><code>-O0 、-O1 、-O2 、-O3</code> 编译器优化，<code>O1</code> 缺省，<code>O3</code>级别最高</li><li><code>g</code> 产生调试信息</li><li><code>Wall</code> 生成所有 warning / <code>w</code> 不生成 warning</li></ul><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><p>阿，后天回学校了。今年也马上要到头了，最近有点烦恼阿。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">跟我一起写Makefile:MakeFile介绍</a></li><li><a href="http://www.runoob.com/w3cnote/gcc-parameter-detail.html" target="_blank" rel="noopener">GCC参数详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="linux" scheme="https://blog.pwxcoo.com/tags/linux/"/>
    
      <category term="gcc" scheme="https://blog.pwxcoo.com/tags/gcc/"/>
    
      <category term="makefile" scheme="https://blog.pwxcoo.com/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>浅谈随机数</title>
    <link href="https://blog.pwxcoo.com/2018/11/29/%E6%B5%85%E8%B0%88%E9%9A%8F%E6%9C%BA%E6%95%B0/"/>
    <id>https://blog.pwxcoo.com/2018/11/29/浅谈随机数/</id>
    <published>2018-11-29T14:24:16.000Z</published>
    <updated>2019-02-07T09:40:26.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伪随机数"><a href="#伪随机数" class="headerlink" title="伪随机数"></a>伪随机数</h2><p>通常编程语言中提供的随机数都是伪随机数，因为都是给定一个种子，然后多项式运算然后这样的，这种提供的随机数是有规律可预测的。</p><p>一个最简单的 C 语言随机数 snippet。但是每次执行的结果都是一样的，因为传入的种子是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> random = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,random);</span><br><span class="line">    random = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,random);</span><br><span class="line">    random = rand();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,random);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>真正的随机数应该是完全不可预测的，通常可以用 linux 下的 <code>/dev/random</code> 或 <code>/dev/urandom</code> 做真随机数生成器。</p><p>这是基于 linux 系统管理 devices 所产生的噪声的，比如磁盘寻道事件，键鼠事件等，因为这些事件噪声很高，熵足够高，所以可以认为是真随机。</p><ul><li><code>/dev/random</code> 用 cat 看一下可以发现知道生成随机数，不够的话就会阻塞。</li><li><code>/dev/urandom</code> 是用之前 <code>/dev/random</code> 生成过的直接返回。</li></ul><p>当然还有一个 <a href="https://www.random.org/" target="_blank" rel="noopener">random.org</a> 的网站，网站提供真随机数，说是通过 <code>atmospheric noise</code> 来提供随机数的。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.zhihu.com/question/20222653" target="_blank" rel="noopener">如何评价一个伪随机数生成算法的优劣？</a></li></ul><h2 id="今天"><a href="#今天" class="headerlink" title="今天"></a>今天</h2><p>换了新电脑 ThinkPadX1C 好开心阿。好轻阿。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="base" scheme="https://blog.pwxcoo.com/categories/base/"/>
    
    
      <category term="base" scheme="https://blog.pwxcoo.com/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>linux下的终端管理tmux</title>
    <link href="https://blog.pwxcoo.com/2018/11/15/linux%E4%B8%8B%E7%9A%84%E7%BB%88%E7%AB%AF%E7%AE%A1%E7%90%86tmux/"/>
    <id>https://blog.pwxcoo.com/2018/11/15/linux下的终端管理tmux/</id>
    <published>2018-11-15T15:00:01.000Z</published>
    <updated>2019-02-07T09:40:26.571Z</updated>
    
    <content type="html"><![CDATA[<p>linux 下的一个终端管理工具 —— tmux 。(Windows 下也有一个很方便的终端管理工具 —— Console Emulator)</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>一个 tmux 对应多个 session，一个 tmux 对应多个 window，一个 window 对应多个 window pane。</p><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tmux</span><br></pre></td></tr></table></figure><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><p>tmux 命令都是由 prefix key + command key 触发的，即先按下 prefix key，然后进入命令模式，然后按 command key。跟 vim 里的 <code>:</code> 异曲同工。默认的 prefix key 为 <code>Ctrl + b</code>。</p><h3 id="操作窗格"><a href="#操作窗格" class="headerlink" title="操作窗格"></a>操作窗格</h3><ul><li><code>%</code> 左右分割</li><li><code>&quot;</code> 上下分割</li><li><code>&lt;arrow key&gt;</code> 窗口导航</li><li><code>Ctrl + &lt;arrow key&gt;</code> 调整大小</li><li><code>z</code> 放大/缩小(zoom)</li></ul><h2 id="操作窗口"><a href="#操作窗口" class="headerlink" title="操作窗口"></a>操作窗口</h2><ul><li><code>c</code> 新建(create)</li><li><code>p</code> 切换到上一个窗口(pre)</li><li><code>n</code> 切换到下一个窗口(next)</li><li><code>&lt;number&gt;</code> 切换到指定的窗口</li><li><code>,</code> 重命名当前窗口</li></ul><h2 id="操作会话"><a href="#操作会话" class="headerlink" title="操作会话"></a>操作会话</h2><ul><li><code>d</code> 回到 bash(detach)</li><li><code>tmux ls</code> 查看当前 tmux sessions</li><li><code>tmux attach -t &lt;number&gt;</code> 连接到指定的 session</li><li><code>tmux new -s {name}</code> 创建会话</li><li><code>tmux rename-session -t &lt;number&gt; {name}</code> 重命名</li><li><code>tmux attach -t {name}</code> 连接到指定的 session</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.csdn.net/yucicheung/article/details/80058338" target="_blank" rel="noopener">Ubuntu下tmux的安装和使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="memo" scheme="https://blog.pwxcoo.com/tags/memo/"/>
    
      <category term="linux" scheme="https://blog.pwxcoo.com/tags/linux/"/>
    
      <category term="tmux" scheme="https://blog.pwxcoo.com/tags/tmux/"/>
    
  </entry>
  
  <entry>
    <title>错排问题</title>
    <link href="https://blog.pwxcoo.com/2018/10/16/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/10/16/错排问题/</id>
    <published>2018-10-16T06:05:52.000Z</published>
    <updated>2019-02-07T09:40:26.579Z</updated>
    
    <content type="html"><![CDATA[<p>错排问题是当 n 个编号元素放在 n 个编号位置，错排的方法数记着 <code>f(n)</code>。</p><p>因为之前面试的时候被问到了，感觉比较有意思，然后好像还挺常见的，所以就记一下好了。</p><p>其实就是动态规划，写出转移方程就好了。</p><ol><li>当 <code>f(n - 1)</code> 然后在放第 n 个元素，此时，对 <code>f(n - 1)</code> 的任何一种情况，第 n 个元素和前 n - 1 个元素交换，都可以的。所以这里有 <code>(n - 1)f(n - 1)</code>。</li><li>当 n - 1 个元素里有一个元素在正确位置，此时为 <code>(n - 1)f(n - 2)</code> 个，此时只要第 n 个元素和其中的正确元素交换，就是一个错排。</li></ol><ul><li>$f(1) = 0$</li><li>$f(2) = 1$</li><li>$f(n) = (n - 1) [f(n - 2) + f(n - 1)]$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
      <category term="dp" scheme="https://blog.pwxcoo.com/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>赛马问题</title>
    <link href="https://blog.pwxcoo.com/2018/10/14/%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/10/14/赛马问题/</id>
    <published>2018-10-14T10:31:41.000Z</published>
    <updated>2019-02-07T09:40:26.579Z</updated>
    
    <content type="html"><![CDATA[<p>一道面试题。</p><blockquote><p>一共 25 匹马，有 5 个赛道，最多有 5 匹马一起跑，最少几场得到最快的 5 匹马？</p></blockquote><ul><li>5 组 A，B，C，D，E，跑 5 次，并排上序。</li><li><p>每组头名再赛一场，得到这样一个矩阵，<code>x</code> 标记的表示已经淘汰了</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">2 3 4 5 x</span><br><span class="line">3 4 5 x x</span><br><span class="line">4 5 x x x</span><br><span class="line">5 x x x x</span><br></pre></td></tr></table></figure></li><li><p>然后再找出第二名，因为冠军确定了，所以在 5 个里找 4 个，最慢的那个，那组直接全部淘汰，以此类推，<strong>最多比赛 10 场</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>鸡蛋下落问题</title>
    <link href="https://blog.pwxcoo.com/2018/09/29/%E9%B8%A1%E8%9B%8B%E4%B8%8B%E8%90%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/09/29/鸡蛋下落问题/</id>
    <published>2018-09-29T05:39:01.000Z</published>
    <updated>2019-02-07T09:40:26.579Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候被问到了。。</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>两个鸡蛋从 100 层高的楼往下丢，最少要扔几次鸡蛋才能算出那一层是鸡蛋的临界层？</p><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><h3 id="Mathematic"><a href="#Mathematic" class="headerlink" title="Mathematic"></a>Mathematic</h3><ul><li>第一个鸡蛋从 k 楼下落，如果碎了，那就必须 [1, k - 1] 层试了，然后最坏就是 k 次</li><li>如果没碎，那就是从 [k + 1, 100] 找一个楼层开始试，</li></ul><p>那如果没碎，下一次的楼层如何选择。可以把问题看成一个决策树的样子，要尝试去构造一个满二叉树。</p><blockquote><p>假设第一次在根节点上, 我们选择扔k层, 其”碎子树”的高度显然是k - 1. 为了考虑不碎子树的高度, 设不碎后第二次扔m层(显然m &gt; k ), 则这个新节点的碎子树高度为 m - k - 1, 不碎子树高度仍然未知, 但按照满二叉树的目标, 我们认为它与碎子树相同或少1就好.那么在根节点上的不碎子树的高度就是m - k - 1 + 1, 令它与碎子树高度相同, 于是: m - k - 1 + 1 = k - 1 =&gt; m = k + k - 1</p></blockquote><p>得到如果第一次在 k 层，那么下一次应该高 k - 1 层。</p><p>$$k + (k - 1) + … + 1 = \frac{k(k+1)}{2} = 100 \Rightarrow k \approx 14$$</p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>用 f(n, m) 表示所需最少次数，n 表示楼层高度，m 表示蛋的个数。</p><ul><li>$f(0,m)=0, m&gt;=1$</li><li>$f(n,1)=n, n&gt;=1$</li></ul><p>$$f(n,m)=\min_{1\leq i \leq n}\{\max\{f(i-1,m-1), f(n-i,m)\}\} + 1$$</p><p>这就是状态转移方程了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">@functools.lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    ans = min([max([f(i - <span class="number">1</span>, m - <span class="number">1</span>), f(n - i, m)]) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">100</span>, <span class="number">2</span>))<span class="comment"># 14</span></span><br><span class="line">print(f(<span class="number">200</span>, <span class="number">2</span>))<span class="comment"># 20</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.zhihu.com/question/19690210" target="_blank" rel="noopener">扔鸡蛋 —— 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="interview" scheme="https://blog.pwxcoo.com/categories/interview/"/>
    
    
      <category term="intelligence" scheme="https://blog.pwxcoo.com/tags/intelligence/"/>
    
  </entry>
  
  <entry>
    <title>Untrack files already added to git repository based on .gitignore</title>
    <link href="https://blog.pwxcoo.com/2018/09/25/Untrack-files-already-added-to-git-repository-based-on-gitignore/"/>
    <id>https://blog.pwxcoo.com/2018/09/25/Untrack-files-already-added-to-git-repository-based-on-gitignore/</id>
    <published>2018-09-25T04:07:28.000Z</published>
    <updated>2019-02-07T09:40:26.567Z</updated>
    
    <content type="html"><![CDATA[<p>因为平时用 <code>git add *</code> 习惯了。。往往在第一次 commit 之后，发现有几个文件应该 untrack 的，但是这个时候添加到 .gitignore 已经失效了。。</p><p>这个时候应该要 rm 掉，重新 commit 。</p><h2 id="Step0-commit-all-changes"><a href="#Step0-commit-all-changes" class="headerlink" title="Step0: commit all changes"></a>Step0: commit all changes</h2><p>提交当前所有提交，确保更新后的 .gitignore 被提交了。</p><h2 id="Step1-Remove-everything-from-the-repository"><a href="#Step1-Remove-everything-from-the-repository" class="headerlink" title="Step1: Remove everything from the repository"></a>Step1: Remove everything from the repository</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br></pre></td></tr></table></figure><h2 id="Step2-Re-add-everythin"><a href="#Step2-Re-add-everythin" class="headerlink" title="Step2: Re add everythin"></a>Step2: Re add everythin</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><h2 id="Step3-Commit"><a href="#Step3-Commit" class="headerlink" title="Step3: Commit"></a>Step3: Commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"fix: .gitignore"</span></span><br></pre></td></tr></table></figure><p>然后就好了，clean again。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/" target="_blank" rel="noopener">Untrack files already added to git repository based on .gitignore</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="git" scheme="https://blog.pwxcoo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>搭建git服务器</title>
    <link href="https://blog.pwxcoo.com/2018/09/24/%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://blog.pwxcoo.com/2018/09/24/搭建git服务器/</id>
    <published>2018-09-24T03:05:54.000Z</published>
    <updated>2019-02-07T09:40:26.575Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些原因要搭一个 git 服务器，因为 linux 下文件管理权限的问题，在 ssh 这里踩了一点坑。</p><h2 id="Steps0-add-user"><a href="#Steps0-add-user" class="headerlink" title="Steps0: add user"></a>Steps0: add user</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br><span class="line">$ su git</span><br><span class="line">$ <span class="built_in">cd</span></span><br><span class="line">$ mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="Step1-add-public-key"><a href="#Step1-add-public-key" class="headerlink" title="Step1: add public key"></a>Step1: add public key</h2><p>把公钥传到服务器，然后加到 authorized_keys。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /tmp/id_rsa.pwxcoo.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>多个公钥用换行符 separate。</p><h2 id="Step2-initialize-repository"><a href="#Step2-initialize-repository" class="headerlink" title="Step2: initialize repository"></a>Step2: initialize repository</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /srv/git</span><br><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>然后再自己的电脑上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@gitserver:/srv/git/project.git</span><br></pre></td></tr></table></figure><p>到这里差不多基本的功能都 ok 了。</p><h2 id="Step3-authority-management"><a href="#Step3-authority-management" class="headerlink" title="Step3: authority management"></a>Step3: authority management</h2><p>然后要设置一下 git 用户的权限，不能让 git 用户用 ssh 登录 shell，让 git 用户默认用 git-shell 登录。</p><p>打开 <code>/etc/passwd</code>，修改 git 用户的默认 shell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="ssh-failed"><a href="#ssh-failed" class="headerlink" title="ssh failed?"></a>ssh failed?</h3><p>我用 ssh 的时候，一直失败。。然后 <code>ssh -Tvvv git@gitserver</code> 命令调试的时候也没有找到有用的信息。。</p><p>后来找到了这个 log: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug3: receive packet: type 51</span><br></pre></td></tr></table></figure><p>server 对 ssh 验证的时候，response 了 type 51 的 packet，然后发现是 linux 下文件权限的问题，server 端一直读不到 authorized_keys 。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown yourusername:yourusername /home/yourusername/ -R</span><br><span class="line">$ sudo chmod o-rwx /home/yourusername/ -R</span><br></pre></td></tr></table></figure><h3 id="stricter-authority-management"><a href="#stricter-authority-management" class="headerlink" title="stricter authority management?"></a>stricter authority management?</h3><p>权限管理这里有人做过了工具，可以去找一下，我之后可能要用到。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">搭建Git服务器</a></li><li><a href="https://hackaday.com/2018/06/27/keep-it-close-a-private-git-server-crash-course/" target="_blank" rel="noopener">A PRIVATE GIT SERVER CRASH COURSE</a></li><li><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server" target="_blank" rel="noopener">Git on the Server - Setting Up the Server</a></li><li><a href="https://stackoverflow.com/questions/6448242/git-push-error-insufficient-permission-for-adding-an-object-to-repository-datab" target="_blank" rel="noopener">Git Push Error: insufficient permission for adding an object to repository database</a></li><li><a href="https://superuser.com/questions/1137438/ssh-key-authentication-fails" target="_blank" rel="noopener">SSH-Key authentication fails</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="git" scheme="https://blog.pwxcoo.com/tags/git/"/>
    
      <category term="linux" scheme="https://blog.pwxcoo.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>一次http请求全过程</title>
    <link href="https://blog.pwxcoo.com/2018/09/17/%E4%B8%80%E6%AC%A1http%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://blog.pwxcoo.com/2018/09/17/一次http请求全过程/</id>
    <published>2018-09-17T15:37:40.000Z</published>
    <updated>2019-02-07T09:40:26.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Q: <strong>一次 http 请求的过程？</strong></p><h2 id="得到自己的IP地址"><a href="#得到自己的IP地址" class="headerlink" title="得到自己的IP地址"></a>得到自己的IP地址</h2><p> (假设此时主机还未配置自己的 IP 地址。) </p><p>用 DHCP (Dynamic Host Configuration Protocol) 得到自己的 IP 地址。</p><ol><li><p>发送 DHCP 请求</p><ul><li>应用层: 生成一个 DHCP 请求报文</li><li>传输层: 加上一个 UDP 头<ul><li>源端口 68</li><li>目标端口 67</li></ul></li><li>网络层: 加上一个 IP 头<ul><li>源IP: 0.0.0.0</li><li>目标IP: 255.255.255.255</li></ul></li><li>数据链路层: 封装成帧<ul><li>源MAC: 自己的 MAC</li><li>目标MAC: FF:FF:FF:FF:FF:FF</li></ul></li></ul></li><li><p>DHCP 服务器 (连接在同一个交换机上) 就到请求后，返回一个 DHCP ACK 报文: </p></li></ol><ul><li>分配给 DHCP 请求的 IP</li><li>DNS 服务器的 IP</li><li>默认网关路由器的 IP</li><li>子网掩码</li></ul><ol start="3"><li>交换机收到之后，缓存一下，发给主机，主机就得到这些信息</li></ol><h2 id="查找默认网关的MAC地址"><a href="#查找默认网关的MAC地址" class="headerlink" title="查找默认网关的MAC地址"></a>查找默认网关的MAC地址</h2><p> (刚刚配置好 DHCP 需要去找到默认网关的 MAC 地址) </p><p>请求要发给默认网关的 MAC 地址，才能把请求发到局域网外部去，相当于发给默认网关路由器后，会根据 NAT 把局域网内部的 IP 地址变成局域网的 IP 地址然后发给局域网外部。</p><ol start="4"><li>生成一个 ARP 查询报文，目标 IP 是默认网关路由器，封装成帧后是一个广播帧</li><li>路由器返回一个 ARP 应答报文给主机，包含了自己的 IP 地址</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ol start="6"><li>生成 DNS 查询报文<ul><li>应用层: 目的域名</li><li>传输层: 目的端口 53</li><li>数据链路层: 默认网关路由器 MAC 地址</li></ul></li><li>默认网关路由器收到后，根据路由表转发<ul><li>内部网关协议 (RIP，OSPF) </li><li>外部网关协议 (BGP) </li></ul></li><li>DNS 解析完了，封装成 UDP =&gt; 默认网关路由器 =&gt; 交换机 =&gt; 主机</li></ol><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><ol start="9"><li>生成 TCP 套接字</li><li>3 次握手</li><li>发送 HTTP 报文</li><li>响应返回，浏览器渲染</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>有的网站是 https 的，通常会把 http 请求 301 重定向到 443 端口。</p><ul><li>server 发送证书和公钥给 client</li><li>client 去 CA 验证安全性</li><li>client 用公钥加密一个随机生成的对称密钥</li><li>server 用私钥解密，然后之后都用这个对称密钥来加密</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="interview" scheme="https://blog.pwxcoo.com/categories/interview/"/>
    
    
      <category term="computer network" scheme="https://blog.pwxcoo.com/tags/computer-network/"/>
    
  </entry>
  
  <entry>
    <title>LRU cache</title>
    <link href="https://blog.pwxcoo.com/2018/09/11/LRU-cache/"/>
    <id>https://blog.pwxcoo.com/2018/09/11/LRU-cache/</id>
    <published>2018-09-11T06:43:28.000Z</published>
    <updated>2019-02-07T09:40:26.567Z</updated>
    
    <content type="html"><![CDATA[<p>一个 LRU Cache，为了方便，直接用 C++ 写的。</p><p>LRU (Least Recently Used) 缓存分配算法是指，<strong>在缓存空间不足时，淘汰最近最少使用的 Cache</strong>。</p><p>为了让查询和插入删除的时间复杂度都是 $O(1)$，用的是哈希表 + 链表实现，链表保证删除插入为 $O(1)$，哈希表保证查询为 $O(1)$。</p><p>每个缓存用 key-value 类型表示，哈希表中存放 key 和到链表中该 key 节点的指针，链表中存放 key-value。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered&lt;key, <span class="built_in">list</span>::iterator&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;pair&lt;key,value&gt;&gt; l;</span><br></pre></td></tr></table></figure><ul><li>put()<ul><li>map 中是否存在<ul><li>存在找到其在 list 中的位置，放到 list 的 front，更新 map 的映射</li><li>不存在，放到 list 的 front，map 中添加映射</li></ul></li><li>判断缓存是否超出 maxsize，超出淘汰 list 的 last，并在 map 删除 key</li></ul></li><li>get()<ul><li>map 是否存在<ul><li>存在，移动到 list 的 front，更新 map 的映射</li><li>不存在，说明缓存未击中</li></ul></li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author pwxcoo</span></span><br><span class="line"><span class="comment"> * @email pwxcoo@gmail.com</span></span><br><span class="line"><span class="comment"> * @create date 2018-09-11 10:30:47</span></span><br><span class="line"><span class="comment"> * @modify date 2018-09-11 13:28:41</span></span><br><span class="line"><span class="comment"> * @desc LRU cache implemented by c++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LRUCACHE_INCLUDED_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LRUCACHE_INCLUDED_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cache</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keyword">key_t</span>, <span class="keyword">typename</span> <span class="keyword">value_t</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lru_cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">key_t</span>, <span class="keyword">value_t</span>&gt; <span class="keyword">key_value_pair_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">key_value_pair_t</span>&gt;::iterator list_iterator_it;</span><br><span class="line"></span><br><span class="line">    lru_cache(<span class="keyword">size_t</span> max_size) : _max_size(max_size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key, <span class="keyword">const</span> <span class="keyword">value_t</span> &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _cache_items_map.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it != _cache_items_map.end())</span><br><span class="line">        &#123;</span><br><span class="line">            _cache_items_list.erase(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        _cache_items_list.push_front(<span class="keyword">key_value_pair_t</span>(key, value));</span><br><span class="line">        _cache_items_map[key] = _cache_items_list.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_cache_items_map.size() &gt; _max_size)</span><br><span class="line">        &#123;</span><br><span class="line">            _cache_items_map.erase(_cache_items_list.rbegin()-&gt;first);</span><br><span class="line">            _cache_items_list.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> value_t &amp;<span class="title">get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _cache_items_map.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == _cache_items_map.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::range_error(<span class="string">"There is no such key in cache!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> hit = it-&gt;second;</span><br><span class="line">            _cache_items_list.erase(hit);</span><br><span class="line">            _cache_items_list.push_front(*hit);</span><br><span class="line">            _cache_items_map[key] = _cache_items_list.begin();</span><br><span class="line">            <span class="keyword">return</span> hit-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exists</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _cache_items_map.find(key) == _cache_items_list.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _cache_items_map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" cache size:"</span> &lt;&lt; size() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> item : _cache_items_list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" &#123;"</span> &lt;&lt; item.first &lt;&lt; <span class="string">", "</span> &lt;&lt; item.second &lt;&lt; <span class="string">"&#125;"</span></span><br><span class="line">                      &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">key_value_pair_t</span>&gt; _cache_items_list;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">key_t</span>, list_iterator_it&gt; _cache_items_map;</span><br><span class="line">    <span class="keyword">size_t</span> _max_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace cache</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _LRUCACHE_HPP_INCLUDED_ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////// TEST MODULE BEGIN ////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------------[TEST] LRU cache begin-------------------------\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    cache::lru_cache&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cache_lru(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache_lru.debug(<span class="string">"before:"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"put() &#123;key:%d, value:%d&#125; to cache\n"</span>, i, i * i);</span><br><span class="line"></span><br><span class="line">        cache_lru.put(i, i * i);</span><br><span class="line">        assert(cache_lru.get(i) == i * i);</span><br><span class="line"></span><br><span class="line">        cache_lru.debug(<span class="string">"after :"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache_lru.debug(<span class="string">"before:"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"get() &#123;key:%d&#125; from cache: %d\n"</span>, i, cache_lru.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"encountered exception when get &#123;key:%d&#125;: %s\n"</span>, i, e.what());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache_lru.debug(<span class="string">"after :"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------------[TEST] LRU cache end----------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////// TEST MODULE END   /////////////////////////////////////////</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://gist.github.com/pwxcoo/fe9bf9310c03c4ed2d21976d210975fd" target="_blank" rel="noopener">lru.cpp - Gist</a></li><li><a href="https://github.com/lamerman/cpp-lru-cache" target="_blank" rel="noopener">lamerman/cpp-lru-cache</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
      <category term="operate system" scheme="https://blog.pwxcoo.com/tags/operate-system/"/>
    
      <category term="cache" scheme="https://blog.pwxcoo.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>CRC校验</title>
    <link href="https://blog.pwxcoo.com/2018/09/08/CRC%E6%A0%A1%E9%AA%8C/"/>
    <id>https://blog.pwxcoo.com/2018/09/08/CRC校验/</id>
    <published>2018-09-08T07:36:19.000Z</published>
    <updated>2019-02-07T09:40:26.567Z</updated>
    
    <content type="html"><![CDATA[<p>因为前几天笔试题的时候，让我手算 CRC 校验。。然后今天随手写了一个 CRC 校验的脚本。</p><p>当然了，现实中的 CRC 校验是在数据链路层实现的，都是硬件完成的，我只是模拟一下 CRC 校验的过程。</p><h2 id="CRC简介"><a href="#CRC简介" class="headerlink" title="CRC简介"></a>CRC简介</h2><p>现实中通信线路都不会是理想的，比特在传输过程中会出现差错的，比如 0 变成 1，1 变成 0，这个就叫做 <strong>比特差错</strong>。传输错误的比特占比特总数的比率叫做 <strong>误码率 BER (Bit Error Rate) </strong>。</p><p>为了保证数据传输的可靠性，必须采用各种差错检测措施，目前在数据链路层广泛采用了 CRC (Cyclic Redundancy Check) 的检测技术。</p><h2 id="CRC-过程"><a href="#CRC-过程" class="headerlink" title="CRC 过程"></a>CRC 过程</h2><p>数据链路层的数据单位是帧 (frame) 。</p><p>双方要事先约定一个除数 P，P 可以用多项式表示，P(X) 叫做 <strong>生成多项式</strong>。</p><p>几种常见的生成多项式: </p><table><thead><tr><th>CRC P</th><th>Checksum Width</th><th>Generator Polynomial</th></tr></thead><tbody><tr><td>CRC-CCITT</td><td>16 bits</td><td>10001000000100001</td></tr><tr><td>CRC-16</td><td>16 bits</td><td>11000000000000101 </td></tr><tr><td>CRC-32</td><td>32 bits</td><td>100000100110000010001110110110111</td></tr></tbody></table><hr><p>CRC 的过程大概是这样的: </p><ul><li>P 的长度为 n，frame 就左移 (n - 1) 的长度，相当于在后面加上 (n - 1) 个零，此时 frameM = $frame * 2 ^ {n}$</li><li>然后就是 frameM 作为被除数，P 作为除数，做二进制的模 2 运算 (相当于做二进制加法，但是不进位，<strong>其实跟异或一样</strong>) 。</li><li>求出余数，就是 FCS (Frame Check Sequence) ，加在 frame 后面</li><li>接收端收到 frame 后，同样跟 P 做模 2 运算，如果正确的话，<strong>余数一定是 0</strong>，表示没有差错，就接受，如果出错的话，无法判断哪个出错，就丢弃</li></ul><p>这个图中的原始的 frame 是 10110011，P 是 11001，P 的长度是 n 为 5，所以给原始的 frame 填上 4 个零 (填上 n - 1 个零) ，然后求出余数为 FCS 为 0100，加在原始的 frame 后面，变成 101100110100 传给接收端，接收端收到 101100110100 后，跟 P 做模 2 运算，余数为 0 则表示差错，然后接受这个帧。</p><p><img src="https://i.loli.net/2018/09/08/5b938180e1c25.png" alt="crc.png"></p><p>最后可以实现的是，<strong>在接收端数据链路层接受的帧均无差错</strong>。</p><h2 id="CRC-代码实现"><a href="#CRC-代码实现" class="headerlink" title="CRC 代码实现"></a>CRC 代码实现</h2><ul><li>check() 函数就是模 2 运算，算出余数 (FCS) </li><li>crc() 就给 frame 填上零然后做模 2 运算，返回运算的余数。</li><li>别的就是我随机生成一个二进制的 frame 和几个常见生成多项式做的测试代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(frame, p)</span>:</span></span><br><span class="line">  n = len(p) - <span class="number">1</span></span><br><span class="line">  fcs = frame[<span class="number">0</span>: n]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(frame)):</span><br><span class="line">    fcs += frame[i]</span><br><span class="line">    fcs = bin(int(fcs, <span class="number">2</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> (len(fcs) &lt; len(p)): </span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    fcs = bin(int(fcs, <span class="number">2</span>) ^ int(p, <span class="number">2</span>))[<span class="number">2</span>:]</span><br><span class="line">  <span class="keyword">while</span> len(fcs) &lt; n:</span><br><span class="line">    fcs = <span class="string">"0"</span> + fcs</span><br><span class="line">  <span class="keyword">return</span> fcs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crc</span><span class="params">(frame, p)</span>:</span></span><br><span class="line">  n = len(p) - <span class="number">1</span></span><br><span class="line">  frameM = frame +  n * <span class="string">"0"</span></span><br><span class="line">  <span class="keyword">return</span> check(frameM, p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(p)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    frame = random.choice(<span class="string">"01"</span>) * random.randint(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">assert</span> check(frame + crc(frame, p), p) == (len(p) - <span class="number">1</span>) * <span class="string">"0"</span>, <span class="string">f"encountered error when tested <span class="subst">&#123;p&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRC_16 = <span class="string">"11000000000000101"</span>                    <span class="comment"># 16 bits</span></span><br><span class="line">CRC_CCITT = <span class="string">"10001000000100001"</span>                 <span class="comment"># 16 bits</span></span><br><span class="line">CRC_32 = <span class="string">"100000100110000010001110110110111"</span>    <span class="comment"># 32 bits</span></span><br><span class="line"></span><br><span class="line">test(CRC_16)</span><br><span class="line">test(CRC_CCITT)</span><br><span class="line">test(CRC_32)</span><br><span class="line">print(<span class="string">"Accept"</span>)</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://gist.github.com/pwxcoo/a664bf4b05f845e2891ed7fccd9dcffe" target="_blank" rel="noopener">CRC.py - GIST</a></li><li><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Designing_polynomials" target="_blank" rel="noopener">Cyclic redundancy check</a></li><li><a href="https://barrgroup.com/Embedded-Systems/How-To/CRC-Math-Theory" target="_blank" rel="noopener">CRC Mathematics and Theory</a></li><li>谢希仁的《计算机网络》第六版</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="tech" scheme="https://blog.pwxcoo.com/categories/tech/"/>
    
    
      <category term="computer network" scheme="https://blog.pwxcoo.com/tags/computer-network/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java并发</title>
    <link href="https://blog.pwxcoo.com/2018/09/07/%E6%B5%85%E8%B0%88Java%E5%B9%B6%E5%8F%91/"/>
    <id>https://blog.pwxcoo.com/2018/09/07/浅谈Java并发/</id>
    <published>2018-09-07T05:18:47.000Z</published>
    <updated>2019-02-07T09:40:26.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h2><p><img src="https://i.loli.net/2018/09/07/5b920cd0dd44e.png" alt="concurrent"></p><p><strong>Java 中的线程概念是操作系统线程概念的一个 wrapper。</strong></p><ul><li>操作系统中线程状态<ul><li>New</li><li>Ready</li><li>Blocked</li><li>Running</li><li>Terminated</li></ul></li><li>Java中的线程状态 (Java 中的线程是对操作系统线程的再次封装) <ul><li>New </li><li>Runnable (Thread.start())</li><li>Blocked (synchronized, Lock)</li><li>Time Waiting (Thread.sleep())</li><li>Waiting (Object.wait(), Object.notify())</li><li>Terminated (Exception)</li></ul></li></ul><h3 id="wait-和-sleep-和-yield"><a href="#wait-和-sleep-和-yield" class="headerlink" title="wait() 和 sleep() 和 yield() ?"></a>wait() 和 sleep() 和 yield() ?</h3><ul><li>wait() 方法会释放 CPU 执行权和占有的锁。<strong>(三者中只有用 wait() 会释放锁)</strong></li><li>sleep() 方法仅释放 CPU 使用权，锁仍然占用；线程被放入超时等待队列，与 yield() 相比，它会使线程较长时间得不到运行。</li><li>yield() 方法仅释放 CPU 执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</li><li>wait() 和 notify() 必须配套使用，即必须使用同一把锁调用；</li><li>wait() 和 notify() 必须放在一个同步块中调用</li><li>wait() 和 notify() 的对象必须是他们所处同步块的锁对象。</li></ul><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><ul><li><p>Runnable</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Callable</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Thread</p></li></ul><hr><p>Callable 可以用 Future 来获得返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future 是一个接口，Future 提供了三种功能: </p><ul><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ul><p>同时还有一个 FutureTask 的类，FutureTask 的父类是 RunnableFuture，而 RunnableFuture 继承了 Runnbale 和 Futrue 这两个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><p><strong>跟线程一样，Java 中的线程是对操作系统的线程概念的 wrapper，而 Java 中的同步问题也是操作系统的同步问题的 wrapper。</strong></p><h3 id="操作系统中的同步问题"><a href="#操作系统中的同步问题" class="headerlink" title="操作系统中的同步问题"></a>操作系统中的同步问题</h3><ul><li>进程同步<ul><li>信号量</li><li>管程 (monitor) </li><li>消息传递</li></ul></li><li>线程同步<ul><li>临界区 (Critical Section) </li><li>互斥量 (Mutex) </li><li>信号量 (Semaphore) </li><li>事件 (Event) </li></ul></li></ul><h3 id="Java中线程同步问题"><a href="#Java中线程同步问题" class="headerlink" title="Java中线程同步问题"></a>Java中线程同步问题</h3><ul><li>synchronized<ul><li>Java中每个对象都有一个内置锁 (修饰静态方法的时候，会锁住整个类) </li></ul></li><li>重入锁 (java.util.concurrent) ，ReentrantLock<ul><li>实现是一个自旋锁，循环调用 CAS 操作来实现加锁</li></ul></li><li>ThreadLocal<ul><li>如果使用 ThreadLocal 管理变量，则每一个使用该变量的线程都获得该变量的副本</li></ul></li><li>使用阻塞队列实现线程同步<ul><li>java.util.concurrent 的 LinkedBlockingQueue<e></e></li></ul></li><li>使用原子变量实现线程同步<ul><li>java.util.concurrent.atomic，比如其中的 AtomicInteger</li></ul></li><li><p>wait() 和 notify()</p><ul><li><p>示例代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncStack ss = <span class="keyword">new</span> SyncStack();</span><br><span class="line"></span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(ss);</span><br><span class="line">        Consumer c = <span class="keyword">new</span> Consumer(ss);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Thread(p).start();</span></span><br><span class="line"><span class="comment">//        new Thread(p).start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Goods(<span class="keyword">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Goods : "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Goods[] arrWT = <span class="keyword">new</span> Goods[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Goods wt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index == arrWT.length) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"满了"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        arrWT[index] = wt;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Goods <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"不够"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">return</span> arrWT[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    SyncStack ss = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Producer(SyncStack ss) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ss = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Goods goods = <span class="keyword">new</span> Goods(i);</span><br><span class="line">            ss.push(goods);</span><br><span class="line">            System.out.println(<span class="string">"生产了: "</span> + goods);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    SyncStack ss = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Consumer(SyncStack ss) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ss = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Goods goods = ss.pop();</span><br><span class="line">            System.out.println(<span class="string">"消费了: "</span> + goods);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Condition 是在 java 1.5 中才出现的，它用来替代传统的 Object 的 wait()、notify() 实现线程间的协作，相比使用 Object 的 wait()、notify()，使用 Condition 的await()、signal() 这种方式实现线程间协作更加安全和高效。</p></li></ul></li></ul><h3 id="ReenTrantLock-和-synchronized-的区别"><a href="#ReenTrantLock-和-synchronized-的区别" class="headerlink" title="ReenTrantLock 和 synchronized 的区别?"></a>ReenTrantLock 和 synchronized 的区别?</h3><ul><li>ReenTrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。</li><li>ReenTrantLock 提供了一个 Condition (条件) 类，用来实现分组唤醒需要唤醒的线程们，而不是像 synchronized 要么随机唤醒一个线程要么唤醒全部线程。</li><li>ReenTrantLock 提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.jianshu.com/p/cf12d4244171" target="_blank" rel="noopener">Java并发之Runnable、Callable、Future、FutureTask</a></li><li><a href="https://www.cnblogs.com/Allen-rg/p/7172958.html" target="_blank" rel="noopener">进程同步的几种方式</a></li><li><a href="https://www.cnblogs.com/Allen-rg/p/7172970.html" target="_blank" rel="noopener">线程同步的几种方式</a></li><li><a href="https://blog.csdn.net/qq838642798/article/details/65441415" target="_blank" rel="noopener">ReenTrantLock可重入锁 (和synchronized的区别) 总结</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/a015b110387eb4a183fac7dc9526de6cd9e316b3/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">CS-Notes/notes/Java 并发.md</a></li><li><a href="https://blog.csdn.net/zqz_zqz/article/details/70246212" target="_blank" rel="noopener">java对象结构</a></li><li><a href="https://www.cnblogs.com/wewill/p/8058292.html" target="_blank" rel="noopener">锁原理: 偏向锁、轻量锁、重量锁</a></li><li><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">java 中的锁 – 偏向锁、轻量级锁、自旋锁、重量级锁</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="base" scheme="https://blog.pwxcoo.com/categories/base/"/>
    
    
      <category term="java" scheme="https://blog.pwxcoo.com/tags/java/"/>
    
      <category term="concurrent" scheme="https://blog.pwxcoo.com/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Redis和缓存</title>
    <link href="https://blog.pwxcoo.com/2018/09/06/%E6%B5%85%E8%B0%88Redis%E5%92%8C%E7%BC%93%E5%AD%98/"/>
    <id>https://blog.pwxcoo.com/2018/09/06/浅谈Redis和缓存/</id>
    <published>2018-09-06T04:00:54.000Z</published>
    <updated>2019-02-07T09:40:26.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存的淘汰策略"><a href="#缓存的淘汰策略" class="headerlink" title="缓存的淘汰策略"></a>缓存的淘汰策略</h2><ul><li>FIFO(Fisrt In First Out)</li><li>LRU(Least Recently Used)</li></ul><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><ul><li>浏览器</li><li>ISP</li><li>反向代理</li><li>服务器本地缓存</li><li>分布式缓存</li><li>数据库缓存</li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN(Content distribution network)。利用更靠近用户的服务器从而更快更可靠地将内容分发给用户。</p><blockquote><p>For that CDN will stores the data in multiple servers so once a data request arises from a visitor the CDN will take the data from the nearest server located near to the visitor and display it to the visitor.</p></blockquote><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>对不存在的数据进行请求，该请求会穿透缓存到达数据库。</p><ul><li>为不存在的数据缓存一个空数据</li><li>对这类请求过滤</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>数据没 load 到缓存中，或者缓存在同一个时间大面积失效，或者缓存服务器宕机，导致大量请求都到达数据库。</p><ul><li>观察用户行为，合理设置缓存时间 (或者给每个缓存加上一个随机值，避免集体失效) </li><li>分布式缓存，每个节点只缓存部分的数据，某个节点宕机的时候保证其他节点仍然可用</li><li>缓存预热，防止系统刚启动时还未将大量数据进行缓存而导致的雪崩  </li></ul><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><ul><li>数据更新，立刻更新缓存</li><li>读取的时候判断是否是最新，不是再更新 (惰性) </li></ul><p>保证缓存一致性需要付出很大的代价，缓存数据适合那些一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h2 id="分布式缓存的数据分布"><a href="#分布式缓存的数据分布" class="headerlink" title="分布式缓存的数据分布"></a>分布式缓存的数据分布</h2><ul><li>哈希分布</li><li>顺序分布</li></ul><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>Distributed Hash Table(DHT)。</p><p>将哈希空间 $[0, 2^{n}-1]$ 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis(Remote Dictionary Server)。</p><p>Key-Value 类型的数据库，纯内存操作。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>STRING, 字符串 + 整型 + 浮点数<ul><li>字符串操作</li><li>数字加减</li></ul></li><li>LIST<ul><li>列表操作</li><li><strong>可以用来做消息队列</strong></li></ul></li><li>SET<ul><li>添加，删除，检查</li><li>交集，并集，差集</li><li><strong>可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</strong></li></ul></li><li>HASH<ul><li>添加，删除，检查</li><li>遍历</li><li><strong>可以用来做模拟 session</strong></li></ul></li><li>ZSET<ul><li>根据分值范围或者成员来获取元素</li><li>添加，删除，检查</li><li>计算排名</li><li><strong>可以做做排行榜</strong></li></ul></li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>定期删除 + 惰性删除。</p><p>在 redis.conf 中配置内存淘汰策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><ul><li>noeviction: throw error</li><li>allkeys-lru: LRU for all keys</li><li>allkeys-random: random for all keys</li><li>volatile-lru: LRU for expired keys</li><li>volatile-random: random for expired keys</li><li>volatile-ttl: remove the latest key for expired keys</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://redis.io/commands" target="_blank" rel="noopener">redis commands</a></li><li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">redis-tutorial</a></li><li><strong><a href="https://baijiahao.baidu.com/s?id=1594341157941741587&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">Redis的几道面试题</a></strong></li><li><a href="https://blog.csdn.net/hjm4702192/article/details/80518856" target="_blank" rel="noopener">Redis 总结精讲</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/a015b110387eb4a183fac7dc9526de6cd9e316b3/notes/Redis.md#%E8%B7%B3%E8%B7%83%E8%A1%A8" target="_blank" rel="noopener">CS-Notes/notes/Redis.md</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="base" scheme="https://blog.pwxcoo.com/categories/base/"/>
    
    
      <category term="cache" scheme="https://blog.pwxcoo.com/tags/cache/"/>
    
      <category term="redis" scheme="https://blog.pwxcoo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫环</title>
    <link href="https://blog.pwxcoo.com/2018/09/05/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    <id>https://blog.pwxcoo.com/2018/09/05/约瑟夫环/</id>
    <published>2018-09-05T09:13:59.000Z</published>
    <updated>2019-02-07T09:40:26.579Z</updated>
    
    <content type="html"><![CDATA[<p>约瑟夫环。感觉刚上大学的时候见过这个题目，昨天做笔试题的时候遇到了。。第一反应就是链表。。复杂度 $O(nm)$。不过数据也是水，也是过了。。</p><p>然后事后才知道这是约瑟夫环。用数学递推公式可以降到 $O(n)$。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>推导的过程是一个逆向的过程，<strong>n 环约瑟夫环问题</strong>可以化解成 <strong>n - 1 环约瑟夫环问题</strong>。</p><p>模拟一下约瑟夫环的过程，下标从 0 开始: </p><ol><li>0, 1, … , m - 2, <del><strong>m - 1</strong></del>, <strong>m</strong>, …, n - 2, n - 1 (m - 1个被删去)</li><li>0, 1, … , m - 2, <strong>m</strong>, …, n - 2, n - 1 (从 m 开始重新计数)</li><li>n - m, n - m + 1, …, n - 2, <strong>0</strong>, …, n - 2 - m, n - 1 - m (然后把 0 重新提到最前面)</li><li><strong>0</strong>, 1, …, n - 2</li></ol><p>这就是 <strong>n 环约瑟夫环问题</strong> 变成了 <strong>n - 1 环约瑟夫环问题</strong> 的过程了。</p><p>可以发现在 <strong>n - 1 环约瑟夫环问题</strong> 中下标为 k 的元素，在 <strong>n 环约瑟夫环问题</strong> 中下标变成了 k + m。当然还要取一下余，变成了 (k + m) % n。</p><p>然后可以发现 <strong>在 n = 1 时，被删去的元素一定是下标为 0 的点</strong>。</p><p>然后推出两个结论，f(n) 表示  <strong>n 环约瑟夫环问题</strong> 中被删掉元素下标: </p><ul><li>f(n) = (f(n - 1) + m) % n</li><li>f(1) = 0</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n, m, i, s = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)  </span><br><span class="line">        s = (s + m) % i;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, s);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题</title>
    <link href="https://blog.pwxcoo.com/2018/09/03/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/09/03/01背包问题/</id>
    <published>2018-09-03T15:13:11.000Z</published>
    <updated>2019-02-07T09:40:26.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>有 N 件物品和一个容量为 V 的背包。第i件物品的费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可使价值总和最大。</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>每次问题仅有一件，可以选择放或者不放。</p><p>然后变成一个 DP 问题，用一个 f[i][v] 表示前 i 件物品放入容量为 v 的背包获得的价值，状态转移方程: </p><p>$$f[i][v] = max(f[i-1][v], f[i-1][v - c[i]] + w[i])$$</p><p>时间复杂度 $O(NV)$，空间复杂度 $O(NV)$。</p><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>空间可以优化成 $O(V)$。</p><p>因为计算完了 f[i] 时，只用到了 f[i-1]，f[i-2] 已经没用了，所以优化成一维数组 (滚动数组) ，</p><p>$$f[v] = max(f[v], f[v-c[i]] + w[i])$$</p><h3 id="初始化的细节问题"><a href="#初始化的细节问题" class="headerlink" title="初始化的细节问题"></a>初始化的细节问题</h3><ul><li>不要求恰好装满，f[i] 全部初始化为 0。</li><li>要求恰好装好装满，除 f[0] 为 0，其余全部初始化为 $-\infty$。</li></ul><h3 id="一个常数优化"><a href="#一个常数优化" class="headerlink" title="一个常数优化"></a>一个常数优化</h3><p>此时的伪代码: </p><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>..n</span><br><span class="line">    <span class="keyword">for</span> v=V...c[i]</span><br><span class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>每一层在 v &lt; c[i] 时，就不需要往下继续算了，因为肯定不放第 i 个物品了。</li><li>可以发现，在最后的一层遍历中中，只用求出 f[V] 就好了，不需要在遍历到前面了，倒数第一层只需要知道 f[V-c[n]] 的值就好了，也就是说倒数第二层只需要算到 f[V-c[n]]，就可以给倒数第一层用了，那继续推，倒数第三层只要算到 f[V-c[n]-c[n-1]] 就可以满足倒数第二层的需求了。</li></ul><p>优化后: </p><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>..n</span><br><span class="line">    bound=max&#123;c[i], V-sum(c[i+<span class="number">1.</span>..n])&#125;</span><br><span class="line">    <span class="keyword">for</span> v=V...bound</span><br><span class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure></code></pre><p>此优化在 V 非常大时比较有用。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>求出那些物品被放了，那些物品没被放？<ul><li>这种就要用二维数组来记录 dp 了，从右下角 f[N][V] 开始遍历，如果 f[i][v] == f[i-1][v] 说明没放，反之放了，然后一直遍历到左上角 f[0][0] 为止</li></ul></li><li>求出第 K 优的解？<ul><li>为 f[] 数组加一维，用来存放前 K 优解，每次更新的时候，按放入 i 个物品的前 K 优解和未放入 i 个物品的前 K 优解重新排序一波，然后将 K 优解放入 f[i]</li><li>相当于找出两个班的前 K 名，需要把两个班的前 K 名都拿出来</li></ul></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>上次笔试题做到一个类似 01 背包的问题，然后没 A 掉。。我还记得我大二的时候还做过关于动态规划的 ppt，01 背包还是我当时的案例。。现在。。我恨。。</p><p>学一次，忘一次。。这次要记下来。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.kancloud.cn/kancloud/pack/70125" target="_blank" rel="noopener">第一讲 01背包问题 - 背包九讲</a></li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-04/hdu2546.cpp" target="_blank" rel="noopener">hdu2546</a> / 01背包</li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-04/hdu1171.cpp" target="_blank" rel="noopener">hdu1171</a> / 01背包</li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-05/hdu2602.cpp" target="_blank" rel="noopener">hdu2602</a> / 01背包</li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-05/hdu2639.cpp" target="_blank" rel="noopener">hdu2639</a> / 01背包变形 (求第 K 优解) </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
      <category term="dp" scheme="https://blog.pwxcoo.com/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>浅谈HashMap和ConcurrentHashMap</title>
    <link href="https://blog.pwxcoo.com/2018/08/31/%E6%B5%85%E8%B0%88HashMap%E5%92%8CConcurrentHashMap/"/>
    <id>https://blog.pwxcoo.com/2018/08/31/浅谈HashMap和ConcurrentHashMap/</id>
    <published>2018-08-31T11:50:50.000Z</published>
    <updated>2019-02-07T09:40:26.575Z</updated>
    
    <content type="html"><![CDATA[<p>本篇的源码基于我自己电脑上的 <strong>jdk1.8.0_161</strong> 。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>HashMap 在 jdk1.7 里是数组 + 链表，哈希冲突用拉链 (头插法) 解决。</li><li>HashMap 在 jdk1.8 里是数组 + 链表/红黑树，哈希冲突用拉链 (头插法) 解决 (链表太长就用红黑树) 。</li></ul><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_INITIAL_CAPACITY，默认 HashMap 的大小</li><li>MAXIMUM_CAPACITY，最大的 HashMap 的大小</li><li>DEFAULT_LOAD_FACTOR，默认的负载因子的大小</li><li>TREEIFY_THRESHOLD，将链表升级成红黑树的 threshold</li><li>UNTREEIFY_THRESHOLD，当 HashMap 删除元素后，红黑树退化成链表的 threshold</li><li>MIN_TREEIFY_CAPACITY，升级成红黑树的最小容量，表示 HashMap 达到这个容量之后，一定会升级成红黑树或者 resize。 (但是我没在别人的博客里看到过这个。。我只是按照注释理解了一下。。这个东西下面没用到) </li><li><p>table[]，存放数据的数组，每个元素是一个内部类 Node</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hash 就是 hash 值</li><li>key 是存放的 key 值</li><li>value 是存放的 value 值</li><li>next 是指向下一个 Node 的引用，生成链表时用的，<strong>如果升级成红黑树，会用 TreeNode (也是一个内部类)  代替 Node</strong></li></ul></li><li>size，HashMap 的 size</li><li>modCount，表示 HashMap 的 structural modified 次数 (比如，添加删除元素，或者 resize 都算，但是如果仅仅是值的改变不算) 。当迭代操作或者序列化操作时，操作前后需要比较 modCount 是否相等，不相等就 Fail-Fast，抛出 ConcurrentModificationException。</li><li>threshold，resize 的大小，等于  (capacity * load factor) ，达到 threshold 的时候就会扩容 (会 rehash，复制数据等操作，比较消耗性能) </li><li>loadFactor，负载因子</li></ul><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前 table 是否未初始化，未初始化就初始化一波</li><li>根据 hash 值定位到具体的 bin，如果这个 bin 为空，直接新建一个 bin 放入这个 Node，<strong>然后返回</strong></li><li>判断 key 是否和当前结点的 key 相等，相等就直接替换 Node (或者 key 都为 null 的时候，HashMap 允许 key 为 null，顺便再插一句，HashMap 中 null 无法计算其 hash 值，默认都是放到下标为 0 的  上) </li><li>如果当前结点是 TreeNode 红黑树结点，就按红黑树的方法插入 (具体就不展开了) </li><li>如果是链表，就遍历链表，找到相同的 key 的 Node 就可以直接替换 Node，如果没找到就 newNode() (这个方法会在对应的 bin 中插入 Node) </li><li>统一替换 Node (即 e 不为空) </li><li>modCount 自增</li><li>判断是否需要 resize</li></ul><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">* or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">* key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">* it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">* indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">* possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">* The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">* distinguish these two cases.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断 table 是否未初始化，未初始化或者定位到的 bin 为空的话，直接<strong>返回 null</strong></li><li>判断第一个 Node/TreeNode 的值是否为查询的 key，是的话直接返回 (always check first node) ，若不匹配就下一步</li><li>判断为 TreeNode，查找红黑树</li><li>判断链表，遍历链表查找</li></ul><h3 id="并发下会形成环形链表"><a href="#并发下会形成环形链表" class="headerlink" title="并发下会形成环形链表"></a>并发下会形成环形链表</h3><p>一个例子: </p><ol><li>刚开始，设 length 为 4，threshold 为 3，现在要扩容了<ul><li>0: </li><li>1: 5 -&gt; 9 -&gt; 17</li><li>2: </li><li>3: </li></ul></li><li>thread1 执行扩容中，此时执行到 9 这个 Node: <ul><li>0: </li><li>1: <strong>9</strong> -&gt; 17</li><li>2:</li><li>3:</li><li>4:</li><li>5: 5</li><li>6: </li><li>7: </li></ul></li><li>thread2 执行完成: <ul><li>0: </li><li>1: 17 -&gt; 9 </li><li>2:</li><li>3:</li><li>4:</li><li>5: 5</li><li>6: </li><li>7: </li></ul></li><li>thread1 继续执行，把 rehash 后的 9 插到 1 的 bin 上，头插插入<ul><li>0: </li><li>1: 9 &lt;=&gt; 17</li><li>2:</li><li>3:</li><li>4:</li><li>5: 5</li><li>6: </li><li>7: </li></ul></li></ol><p>这样 9 和 17 成为了对方的 next，形成了环。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>其中的核心数据，如 value，以及链表都是 volatile 修饰的，保证了获取时的可见性。 (可以防止出现环，get 时也不用加锁) </p><ul><li>ConcurrentHashMap 在 jdk1.7 中是由 Segment 数组 (Segment 里存放 HashEntry 数组) 构成的，Segment 继承自 ReentrantLock。<ul><li>put() <ul><li>尝试获取锁，失败说明和其他线程存在竞争，用 <code>canAndLockForPut()</code> 自旋获取锁<ul><li>尝试自旋获取锁</li><li>如果重试次数达到 <code>MAX_SCAN_RETRIES</code>，改为用阻塞锁获取</li></ul></li><li>定位到对应的 HashEntry</li><li>遍历，找到就替换</li><li>没找到就插入一个 HashEntry，并判断是否需要扩容</li><li>解锁</li></ul></li></ul></li><li>ConcurrentHashMap 在 jdk1.8 中加了红黑树并且做了一点结构上的调整，抛弃了 Segment 分段锁，采用了 CAS(Compare And Swap) + synchronized 来保证并发的安全性。</li></ul><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算出 hashCode</li><li>判断是否需要初始化</li><li>如果当前 key 定位的 Node 为空，尝试利用 CAS 写入，失败则自旋保证成功</li><li>如果 hashcode == MOVED，表示已经这个 Node 已经被移动过了 (表示其他线程在进行扩容操作) ，helpTransfer() 是一个辅助方法</li><li>如果都不满足，即当前 key 存在，并且找到了，用 synchronized 锁写入数据</li><li>如果数量大于 TREEIFY_THRESHOLD，升级成红黑树</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大后天回学校！</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></li><li><a href="https://blog.csdn.net/fjse51/article/details/55260493" target="_blank" rel="noopener">jdk1.8中ConcurrentHashMap的实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="tech" scheme="https://blog.pwxcoo.com/categories/tech/"/>
    
    
      <category term="java" scheme="https://blog.pwxcoo.com/tags/java/"/>
    
      <category term="data structure" scheme="https://blog.pwxcoo.com/tags/data-structure/"/>
    
  </entry>
  
</feed>
