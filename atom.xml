<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PWXCOO</title>
  
  <subtitle>内部整修</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.pwxcoo.com/"/>
  <updated>2018-11-16T06:27:49.990Z</updated>
  <id>https://blog.pwxcoo.com/</id>
  
  <author>
    <name>pwxcoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>错排问题</title>
    <link href="https://blog.pwxcoo.com/2018/10/16/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/10/16/错排问题/</id>
    <published>2018-10-16T06:05:52.000Z</published>
    <updated>2018-11-16T06:27:49.990Z</updated>
    
    <content type="html"><![CDATA[<p>错排问题是当 n 个编号元素放在 n 个编号位置，错排的方法数记着 <code>f(n)</code>。</p><p>因为之前面试的时候被问到了，感觉比较有意思，然后好像还挺常见的，所以就记一下好了。</p><p>其实就是动态规划，写出转移方程就好了。</p><ol><li>当 <code>f(n - 1)</code> 然后在放第 n 个元素，此时，对 <code>f(n - 1)</code> 的任何一种情况，第 n 个元素和前 n - 1 个元素交换，都可以的。所以这里有 <code>(n - 1)f(n - 1)</code>。</li><li>当 n - 1 个元素里有一个元素在正确位置，此时为 <code>(n - 1)f(n - 2)</code> 个，此时只要第 n 个元素和其中的正确元素交换，就是一个错排。</li></ol><ul><li>$f(1) = 0$</li><li>$f(2) = 1$</li><li>$f(n) = (n - 1) [f(n - 2) + f(n - 1)]$</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
      <category term="dp" scheme="https://blog.pwxcoo.com/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>赛马问题</title>
    <link href="https://blog.pwxcoo.com/2018/10/14/%E8%B5%9B%E9%A9%AC%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/10/14/赛马问题/</id>
    <published>2018-10-14T10:31:41.000Z</published>
    <updated>2018-11-16T10:59:11.683Z</updated>
    
    <content type="html"><![CDATA[<p>一道面试题。</p><blockquote><p>一共 25 匹马，有 5 个赛道，最多有 5 匹马一起跑，最少几场得到最快的 5 匹马？</p></blockquote><ul><li>5 组 A，B，C，D，E，跑 5 次，并排上序。</li><li><p>每组头名再赛一场，得到这样一个矩阵，<code>x</code> 标记的表示已经淘汰了</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5</span><br><span class="line">2 3 4 5 x</span><br><span class="line">3 4 5 x x</span><br><span class="line">4 5 x x x</span><br><span class="line">5 x x x x</span><br></pre></td></tr></table></figure></li><li><p>然后再找出第二名，因为冠军确定了，所以在 5 个里找 4 个，最慢的那个，那组直接全部淘汰，以此类推，<strong>最多比赛 10 场</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>鸡蛋下落问题</title>
    <link href="https://blog.pwxcoo.com/2018/09/29/%E9%B8%A1%E8%9B%8B%E4%B8%8B%E8%90%BD%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/09/29/鸡蛋下落问题/</id>
    <published>2018-09-29T05:39:01.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<p>面试的时候被问到了。。</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>两个鸡蛋从 100 层高的楼往下丢，最少要扔几次鸡蛋才能算出那一层是鸡蛋的临界层？</p><h2 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h2><h3 id="Mathematic"><a href="#Mathematic" class="headerlink" title="Mathematic"></a>Mathematic</h3><ul><li>第一个鸡蛋从 k 楼下落，如果碎了，那就必须 [1, k - 1] 层试了，然后最坏就是 k 次</li><li>如果没碎，那就是从 [k + 1, 100] 找一个楼层开始试，</li></ul><p>那如果没碎，下一次的楼层如何选择。可以把问题看成一个决策树的样子，要尝试去构造一个满二叉树。</p><blockquote><p>假设第一次在根节点上, 我们选择扔k层, 其”碎子树”的高度显然是k - 1. 为了考虑不碎子树的高度, 设不碎后第二次扔m层(显然m &gt; k ), 则这个新节点的碎子树高度为 m - k - 1, 不碎子树高度仍然未知, 但按照满二叉树的目标, 我们认为它与碎子树相同或少1就好.那么在根节点上的不碎子树的高度就是m - k - 1 + 1, 令它与碎子树高度相同, 于是: m - k - 1 + 1 = k - 1 =&gt; m = k + k - 1</p></blockquote><p>得到如果第一次在 k 层，那么下一次应该高 k - 1 层。</p><p>$$k + (k - 1) + … + 1 = \frac{k(k+1)}{2} = 100 \Rightarrow k \approx 14$$</p><h3 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h3><p>用 f(n, m) 表示所需最少次数，n 表示楼层高度，m 表示蛋的个数。</p><ul><li>$f(0,m)=0, m&gt;=1$</li><li>$f(n,1)=n, n&gt;=1$</li></ul><p>$$f(n,m)=\min_{1\leq i \leq n}\{\max\{f(i-1,m-1), f(n-i,m)\}\} + 1$$</p><p>这就是状态转移方程了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="meta">@functools.lru_cache(maxsize=None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(n, m)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">    ans = min([max([f(i - <span class="number">1</span>, m - <span class="number">1</span>), f(n - i, m)]) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>)]) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">print(f(<span class="number">100</span>, <span class="number">2</span>))<span class="comment"># 14</span></span><br><span class="line">print(f(<span class="number">200</span>, <span class="number">2</span>))<span class="comment"># 20</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.zhihu.com/question/19690210" target="_blank" rel="noopener">扔鸡蛋 —— 知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="interview" scheme="https://blog.pwxcoo.com/categories/interview/"/>
    
    
      <category term="intelligence" scheme="https://blog.pwxcoo.com/tags/intelligence/"/>
    
  </entry>
  
  <entry>
    <title>Untrack files already added to git repository based on .gitignore</title>
    <link href="https://blog.pwxcoo.com/2018/09/25/Untrack-files-already-added-to-git-repository-based-on-gitignore/"/>
    <id>https://blog.pwxcoo.com/2018/09/25/Untrack-files-already-added-to-git-repository-based-on-gitignore/</id>
    <published>2018-09-25T04:07:28.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>因为平时用 <code>git add *</code> 习惯了。。往往在第一次 commit 之后，发现有几个文件应该 untrack 的，但是这个时候添加到 .gitignore 已经失效了。。</p><p>这个时候应该要 rm 掉，重新 commit 。</p><h2 id="Step0-commit-all-changes"><a href="#Step0-commit-all-changes" class="headerlink" title="Step0: commit all changes"></a>Step0: commit all changes</h2><p>提交当前所有提交，确保更新后的 .gitignore 被提交了。</p><h2 id="Step1-Remove-everything-from-the-repository"><a href="#Step1-Remove-everything-from-the-repository" class="headerlink" title="Step1: Remove everything from the repository"></a>Step1: Remove everything from the repository</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm -r --cached .</span><br></pre></td></tr></table></figure><h2 id="Step2-Re-add-everythin"><a href="#Step2-Re-add-everythin" class="headerlink" title="Step2: Re add everythin"></a>Step2: Re add everythin</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><h2 id="Step3-Commit"><a href="#Step3-Commit" class="headerlink" title="Step3: Commit"></a>Step3: Commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"fix: .gitignore"</span></span><br></pre></td></tr></table></figure><p>然后就好了，clean again。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.codeblocq.com/2016/01/Untrack-files-already-added-to-git-repository-based-on-gitignore/" target="_blank" rel="noopener">Untrack files already added to git repository based on .gitignore</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="git" scheme="https://blog.pwxcoo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>搭建git服务器</title>
    <link href="https://blog.pwxcoo.com/2018/09/24/%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://blog.pwxcoo.com/2018/09/24/搭建git服务器/</id>
    <published>2018-09-24T03:05:54.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<p>因为一些原因要搭一个 git 服务器，因为 linux 下文件管理权限的问题，在 ssh 这里踩了一点坑。</p><h2 id="Steps0-add-user"><a href="#Steps0-add-user" class="headerlink" title="Steps0: add user"></a>Steps0: add user</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser git</span><br><span class="line">$ su git</span><br><span class="line">$ <span class="built_in">cd</span></span><br><span class="line">$ mkdir .ssh &amp;&amp; chmod 700 .ssh</span><br><span class="line">$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="Step1-add-public-key"><a href="#Step1-add-public-key" class="headerlink" title="Step1: add public key"></a>Step1: add public key</h2><p>把公钥传到服务器，然后加到 authorized_keys。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat /tmp/id_rsa.pwxcoo.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>多个公钥用换行符 separate。</p><h2 id="Step2-initialize-repository"><a href="#Step2-initialize-repository" class="headerlink" title="Step2: initialize repository"></a>Step2: initialize repository</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /srv/git</span><br><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure><p>然后再自己的电脑上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@gitserver:/srv/git/project.git</span><br></pre></td></tr></table></figure><p>到这里差不多基本的功能都 ok 了。</p><h2 id="Step3-authority-management"><a href="#Step3-authority-management" class="headerlink" title="Step3: authority management"></a>Step3: authority management</h2><p>然后要设置一下 git 用户的权限，不能让 git 用户用 ssh 登录 shell，让 git 用户默认用 git-shell 登录。</p><p>打开 <code>/etc/passwd</code>，修改 git 用户的默认 shell。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="ssh-failed"><a href="#ssh-failed" class="headerlink" title="ssh failed?"></a>ssh failed?</h3><p>我用 ssh 的时候，一直失败。。然后 <code>ssh -Tvvv git@gitserver</code> 命令调试的时候也没有找到有用的信息。。</p><p>后来找到了这个 log：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">debug3: receive packet: type 51</span><br></pre></td></tr></table></figure><p>server 对 ssh 验证的时候，response 了 type 51 的 packet，然后发现是 linux 下文件权限的问题，server 端一直读不到 authorized_keys 。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown yourusername:yourusername /home/yourusername/ -R</span><br><span class="line">$ sudo chmod o-rwx /home/yourusername/ -R</span><br></pre></td></tr></table></figure><h3 id="stricter-authority-management"><a href="#stricter-authority-management" class="headerlink" title="stricter authority management?"></a>stricter authority management?</h3><p>权限管理这里有人做过了工具，可以去找一下，我之后可能要用到。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137583770360579bc4b458f044ce7afed3df579123eca000" target="_blank" rel="noopener">搭建Git服务器</a></li><li><a href="https://hackaday.com/2018/06/27/keep-it-close-a-private-git-server-crash-course/" target="_blank" rel="noopener">A PRIVATE GIT SERVER CRASH COURSE</a></li><li><a href="https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server" target="_blank" rel="noopener">Git on the Server - Setting Up the Server</a></li><li><a href="https://stackoverflow.com/questions/6448242/git-push-error-insufficient-permission-for-adding-an-object-to-repository-datab" target="_blank" rel="noopener">Git Push Error: insufficient permission for adding an object to repository database</a></li><li><a href="https://superuser.com/questions/1137438/ssh-key-authentication-fails" target="_blank" rel="noopener">SSH-Key authentication fails</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="memo" scheme="https://blog.pwxcoo.com/categories/memo/"/>
    
    
      <category term="git" scheme="https://blog.pwxcoo.com/tags/git/"/>
    
      <category term="linux" scheme="https://blog.pwxcoo.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>一次http请求全过程</title>
    <link href="https://blog.pwxcoo.com/2018/09/17/%E4%B8%80%E6%AC%A1http%E8%AF%B7%E6%B1%82%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>https://blog.pwxcoo.com/2018/09/17/一次http请求全过程/</id>
    <published>2018-09-17T15:37:40.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>Q: <strong>一次 http 请求的过程？</strong></p><h2 id="得到自己的IP地址"><a href="#得到自己的IP地址" class="headerlink" title="得到自己的IP地址"></a>得到自己的IP地址</h2><p>（假设此时主机还未配置自己的 IP 地址。）</p><p>用 DHCP（Dynamic Host Configuration Protocol）得到自己的 IP 地址。</p><ol><li><p>发送 DHCP 请求</p><ul><li>应用层：生成一个 DHCP 请求报文</li><li>传输层：加上一个 UDP 头<ul><li>源端口 68</li><li>目标端口 67</li></ul></li><li>网络层：加上一个 IP 头<ul><li>源IP: 0.0.0.0</li><li>目标IP: 255.255.255.255</li></ul></li><li>数据链路层：封装成帧<ul><li>源MAC: 自己的 MAC</li><li>目标MAC: FF:FF:FF:FF:FF:FF</li></ul></li></ul></li><li><p>DHCP 服务器（连接在同一个交换机上）就到请求后，返回一个 DHCP ACK 报文：</p></li></ol><ul><li>分配给 DHCP 请求的 IP</li><li>DNS 服务器的 IP</li><li>默认网关路由器的 IP</li><li>子网掩码</li></ul><ol start="3"><li>交换机收到之后，缓存一下，发给主机，主机就得到这些信息</li></ol><h2 id="查找默认网关的MAC地址"><a href="#查找默认网关的MAC地址" class="headerlink" title="查找默认网关的MAC地址"></a>查找默认网关的MAC地址</h2><p>（刚刚配置好 DHCP 需要去找到默认网关的 MAC 地址）</p><p>请求要发给默认网关的 MAC 地址，才能把请求发到局域网外部去，相当于发给默认网关路由器后，会根据 NAT 把局域网内部的 IP 地址变成局域网的 IP 地址然后发给局域网外部。</p><ol start="4"><li>生成一个 ARP 查询报文，目标 IP 是默认网关路由器，封装成帧后是一个广播帧</li><li>路由器返回一个 ARP 应答报文给主机，包含了自己的 IP 地址</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ol start="6"><li>生成 DNS 查询报文<ul><li>应用层：目的域名</li><li>传输层：目的端口 53</li><li>数据链路层：默认网关路由器 MAC 地址</li></ul></li><li>默认网关路由器收到后，根据路由表转发<ul><li>内部网关协议（RIP，OSPF）</li><li>外部网关协议（BGP）</li></ul></li><li>DNS 解析完了，封装成 UDP =&gt; 默认网关路由器 =&gt; 交换机 =&gt; 主机</li></ol><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><ol start="9"><li>生成 TCP 套接字</li><li>3 次握手</li><li>发送 HTTP 报文</li><li>响应返回，浏览器渲染</li></ol><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>有的网站是 https 的，通常会把 http 请求 301 重定向到 443 端口。</p><ul><li>server 发送证书和公钥给 client</li><li>client 去 CA 验证安全性</li><li>client 用公钥加密一个随机生成的对称密钥</li><li>server 用私钥解密，然后之后都用这个对称密钥来加密</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="interview" scheme="https://blog.pwxcoo.com/categories/interview/"/>
    
    
      <category term="computer network" scheme="https://blog.pwxcoo.com/tags/computer-network/"/>
    
  </entry>
  
  <entry>
    <title>LRU cache</title>
    <link href="https://blog.pwxcoo.com/2018/09/11/LRU-cache/"/>
    <id>https://blog.pwxcoo.com/2018/09/11/LRU-cache/</id>
    <published>2018-09-11T06:43:28.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>一个 LRU Cache，为了方便，直接用 C++ 写的。</p><p>LRU (Least Recently Used) 缓存分配算法是指，<strong>在缓存空间不足时，淘汰最近最少使用的 Cache</strong>。</p><p>为了让查询和插入删除的时间复杂度都是 $O(1)$，用的是哈希表 + 链表实现，链表保证删除插入为 $O(1)$，哈希表保证查询为 $O(1)$。</p><p>每个缓存用 key-value 类型表示，哈希表中存放 key 和到链表中该 key 节点的指针，链表中存放 key-value。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered&lt;key, <span class="built_in">list</span>::iterator&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;pair&lt;key,value&gt;&gt; l;</span><br></pre></td></tr></table></figure><ul><li>put()<ul><li>map 中是否存在<ul><li>存在找到其在 list 中的位置，放到 list 的 front，更新 map 的映射</li><li>不存在，放到 list 的 front，map 中添加映射</li></ul></li><li>判断缓存是否超出 maxsize，超出淘汰 list 的 last，并在 map 删除 key</li></ul></li><li>get()<ul><li>map 是否存在<ul><li>存在，移动到 list 的 front，更新 map 的映射</li><li>不存在，说明缓存未击中</li></ul></li></ul></li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author pwxcoo</span></span><br><span class="line"><span class="comment"> * @email pwxcoo@gmail.com</span></span><br><span class="line"><span class="comment"> * @create date 2018-09-11 10:30:47</span></span><br><span class="line"><span class="comment"> * @modify date 2018-09-11 13:28:41</span></span><br><span class="line"><span class="comment"> * @desc LRU cache implemented by c++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LRUCACHE_INCLUDED_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _LRUCACHE_INCLUDED_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstddef&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cache</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="keyword">key_t</span>, <span class="keyword">typename</span> <span class="keyword">value_t</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">lru_cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::pair&lt;<span class="keyword">key_t</span>, <span class="keyword">value_t</span>&gt; <span class="keyword">key_value_pair_t</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">key_value_pair_t</span>&gt;::iterator list_iterator_it;</span><br><span class="line"></span><br><span class="line">    lru_cache(<span class="keyword">size_t</span> max_size) : _max_size(max_size) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key, <span class="keyword">const</span> <span class="keyword">value_t</span> &amp;value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _cache_items_map.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it != _cache_items_map.end())</span><br><span class="line">        &#123;</span><br><span class="line">            _cache_items_list.erase(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        _cache_items_list.push_front(<span class="keyword">key_value_pair_t</span>(key, value));</span><br><span class="line">        _cache_items_map[key] = _cache_items_list.begin();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (_cache_items_map.size() &gt; _max_size)</span><br><span class="line">        &#123;</span><br><span class="line">            _cache_items_map.erase(_cache_items_list.rbegin()-&gt;first);</span><br><span class="line">            _cache_items_list.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">const</span> value_t &amp;<span class="title">get</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = _cache_items_map.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == _cache_items_map.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::range_error(<span class="string">"There is no such key in cache!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> hit = it-&gt;second;</span><br><span class="line">            _cache_items_list.erase(hit);</span><br><span class="line">            _cache_items_list.push_front(*hit);</span><br><span class="line">            _cache_items_map[key] = _cache_items_list.begin();</span><br><span class="line">            <span class="keyword">return</span> hit-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">exists</span><span class="params">(<span class="keyword">const</span> <span class="keyword">key_t</span> &amp;key)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _cache_items_map.find(key) == _cache_items_list.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> size() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _cache_items_map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">" cache size:"</span> &lt;&lt; size() &lt;&lt; <span class="string">" | "</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> item : _cache_items_list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" &#123;"</span> &lt;&lt; item.first &lt;&lt; <span class="string">", "</span> &lt;&lt; item.second &lt;&lt; <span class="string">"&#125;"</span></span><br><span class="line">                      &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">key_value_pair_t</span>&gt; _cache_items_list;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">key_t</span>, list_iterator_it&gt; _cache_items_map;</span><br><span class="line">    <span class="keyword">size_t</span> _max_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace cache</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* _LRUCACHE_HPP_INCLUDED_ */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////// TEST MODULE BEGIN ////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------------[TEST] LRU cache begin-------------------------\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    cache::lru_cache&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cache_lru(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache_lru.debug(<span class="string">"before:"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"put() &#123;key:%d, value:%d&#125; to cache\n"</span>, i, i * i);</span><br><span class="line"></span><br><span class="line">        cache_lru.put(i, i * i);</span><br><span class="line">        assert(cache_lru.get(i) == i * i);</span><br><span class="line"></span><br><span class="line">        cache_lru.debug(<span class="string">"after :"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cache_lru.debug(<span class="string">"before:"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"get() &#123;key:%d&#125; from cache: %d\n"</span>, i, cache_lru.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"encountered exception when get &#123;key:%d&#125;: %s\n"</span>, i, e.what());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cache_lru.debug(<span class="string">"after :"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-------------------[TEST] LRU cache end----------------------------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////// TEST MODULE END   /////////////////////////////////////////</span></span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://gist.github.com/pwxcoo/fe9bf9310c03c4ed2d21976d210975fd" target="_blank" rel="noopener">lru.cpp - Gist</a></li><li><a href="https://github.com/lamerman/cpp-lru-cache" target="_blank" rel="noopener">lamerman/cpp-lru-cache</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
      <category term="operate system" scheme="https://blog.pwxcoo.com/tags/operate-system/"/>
    
      <category term="cache" scheme="https://blog.pwxcoo.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>CRC校验</title>
    <link href="https://blog.pwxcoo.com/2018/09/08/CRC%E6%A0%A1%E9%AA%8C/"/>
    <id>https://blog.pwxcoo.com/2018/09/08/CRC校验/</id>
    <published>2018-09-08T07:36:19.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>因为前几天笔试题的时候，让我手算 CRC 校验。。然后今天随手写了一个 CRC 校验的脚本。</p><p>当然了，现实中的 CRC 校验是在数据链路层实现的，都是硬件完成的，我只是模拟一下 CRC 校验的过程。</p><h2 id="CRC简介"><a href="#CRC简介" class="headerlink" title="CRC简介"></a>CRC简介</h2><p>现实中通信线路都不会是理想的，比特在传输过程中会出现差错的，比如 0 变成 1，1 变成 0，这个就叫做 <strong>比特差错</strong>。传输错误的比特占比特总数的比率叫做 <strong>误码率 BER（Bit Error Rate）</strong>。</p><p>为了保证数据传输的可靠性，必须采用各种差错检测措施，目前在数据链路层广泛采用了 CRC（Cyclic Redundancy Check）的检测技术。</p><h2 id="CRC-过程"><a href="#CRC-过程" class="headerlink" title="CRC 过程"></a>CRC 过程</h2><p>数据链路层的数据单位是帧（frame）。</p><p>双方要事先约定一个除数 P，P 可以用多项式表示，P(X) 叫做 <strong>生成多项式</strong>。</p><p>几种常见的生成多项式：</p><table><thead><tr><th>CRC P</th><th>Checksum Width</th><th>Generator Polynomial</th></tr></thead><tbody><tr><td>CRC-CCITT</td><td>16 bits</td><td>10001000000100001</td></tr><tr><td>CRC-16</td><td>16 bits</td><td>11000000000000101 </td></tr><tr><td>CRC-32</td><td>32 bits</td><td>100000100110000010001110110110111</td></tr></tbody></table><hr><p>CRC 的过程大概是这样的：</p><ul><li>P 的长度为 n，frame 就左移 (n - 1) 的长度，相当于在后面加上 (n - 1) 个零，此时 frameM = $frame * 2 ^ {n}$</li><li>然后就是 frameM 作为被除数，P 作为除数，做二进制的模 2 运算（相当于做二进制加法，但是不进位，<strong>其实跟异或一样</strong>）。</li><li>求出余数，就是 FCS（Frame Check Sequence），加在 frame 后面</li><li>接收端收到 frame 后，同样跟 P 做模 2 运算，如果正确的话，<strong>余数一定是 0</strong>，表示没有差错，就接受，如果出错的话，无法判断哪个出错，就丢弃</li></ul><p>这个图中的原始的 frame 是 10110011，P 是 11001，P 的长度是 n 为 5，所以给原始的 frame 填上 4 个零（填上 n - 1 个零），然后求出余数为 FCS 为 0100，加在原始的 frame 后面，变成 101100110100 传给接收端，接收端收到 101100110100 后，跟 P 做模 2 运算，余数为 0 则表示差错，然后接受这个帧。</p><p><img src="https://i.loli.net/2018/09/08/5b938180e1c25.png" alt="crc.png"></p><p>最后可以实现的是，<strong>在接收端数据链路层接受的帧均无差错</strong>。</p><h2 id="CRC-代码实现"><a href="#CRC-代码实现" class="headerlink" title="CRC 代码实现"></a>CRC 代码实现</h2><ul><li>check() 函数就是模 2 运算，算出余数（FCS）</li><li>crc() 就给 frame 填上零然后做模 2 运算，返回运算的余数。</li><li>别的就是我随机生成一个二进制的 frame 和几个常见生成多项式做的测试代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(frame, p)</span>:</span></span><br><span class="line">  n = len(p) - <span class="number">1</span></span><br><span class="line">  fcs = frame[<span class="number">0</span>: n]</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(n, len(frame)):</span><br><span class="line">    fcs += frame[i]</span><br><span class="line">    fcs = bin(int(fcs, <span class="number">2</span>))[<span class="number">2</span>:]</span><br><span class="line">    <span class="keyword">if</span> (len(fcs) &lt; len(p)): </span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    fcs = bin(int(fcs, <span class="number">2</span>) ^ int(p, <span class="number">2</span>))[<span class="number">2</span>:]</span><br><span class="line">  <span class="keyword">while</span> len(fcs) &lt; n:</span><br><span class="line">    fcs = <span class="string">"0"</span> + fcs</span><br><span class="line">  <span class="keyword">return</span> fcs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crc</span><span class="params">(frame, p)</span>:</span></span><br><span class="line">  n = len(p) - <span class="number">1</span></span><br><span class="line">  frameM = frame +  n * <span class="string">"0"</span></span><br><span class="line">  <span class="keyword">return</span> check(frameM, p)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(p)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">50</span>):</span><br><span class="line">    frame = random.choice(<span class="string">"01"</span>) * random.randint(<span class="number">50</span>, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">assert</span> check(frame + crc(frame, p), p) == (len(p) - <span class="number">1</span>) * <span class="string">"0"</span>, <span class="string">f"encountered error when tested <span class="subst">&#123;p&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CRC_16 = <span class="string">"11000000000000101"</span>                    <span class="comment"># 16 bits</span></span><br><span class="line">CRC_CCITT = <span class="string">"10001000000100001"</span>                 <span class="comment"># 16 bits</span></span><br><span class="line">CRC_32 = <span class="string">"100000100110000010001110110110111"</span>    <span class="comment"># 32 bits</span></span><br><span class="line"></span><br><span class="line">test(CRC_16)</span><br><span class="line">test(CRC_CCITT)</span><br><span class="line">test(CRC_32)</span><br><span class="line">print(<span class="string">"Accept"</span>)</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://gist.github.com/pwxcoo/a664bf4b05f845e2891ed7fccd9dcffe" target="_blank" rel="noopener">CRC.py - GIST</a></li><li><a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Designing_polynomials" target="_blank" rel="noopener">Cyclic redundancy check</a></li><li><a href="https://barrgroup.com/Embedded-Systems/How-To/CRC-Math-Theory" target="_blank" rel="noopener">CRC Mathematics and Theory</a></li><li>谢希仁的《计算机网络》第六版</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="tech" scheme="https://blog.pwxcoo.com/categories/tech/"/>
    
    
      <category term="computer network" scheme="https://blog.pwxcoo.com/tags/computer-network/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java并发</title>
    <link href="https://blog.pwxcoo.com/2018/09/07/%E6%B5%85%E8%B0%88Java%E5%B9%B6%E5%8F%91/"/>
    <id>https://blog.pwxcoo.com/2018/09/07/浅谈Java并发/</id>
    <published>2018-09-07T05:18:47.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h2><p><img src="https://i.loli.net/2018/09/07/5b920cd0dd44e.png" alt="concurrent.png"></p><p><strong>Java 中的线程概念是操作系统线程概念的一个 wrapper。</strong></p><ul><li>操作系统中线程状态<ul><li>New</li><li>Ready</li><li>Blocked</li><li>Running</li><li>Terminated</li></ul></li><li>Java中的线程状态（Java 中的线程是对操作系统线程的再次封装）<ul><li>New </li><li>Runnable (Thread.start())</li><li>Blocked (synchronized, Lock)</li><li>Time Waiting (Thread.sleep())</li><li>Waiting (Object.wait(), Object.notify())</li><li>Terminated (Exception)</li></ul></li></ul><h3 id="wait-和-sleep-和-yield"><a href="#wait-和-sleep-和-yield" class="headerlink" title="wait() 和 sleep() 和 yield() ?"></a>wait() 和 sleep() 和 yield() ?</h3><ul><li>wait() 方法会释放 CPU 执行权和占有的锁。<strong>(三者中只有用 wait() 会释放锁)</strong></li><li>sleep() 方法仅释放 CPU 使用权，锁仍然占用；线程被放入超时等待队列，与 yield() 相比，它会使线程较长时间得不到运行。</li><li>yield() 方法仅释放 CPU 执行权，锁仍然占用，线程会被放入就绪队列，会在短时间内再次执行。</li><li>wait() 和 notify() 必须配套使用，即必须使用同一把锁调用；</li><li>wait() 和 notify() 必须放在一个同步块中调用</li><li>wait() 和 notify() 的对象必须是他们所处同步块的锁对象。</li></ul><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><ul><li><p>Runnable</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Callable</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Thread</p></li></ul><hr><p>Callable 可以用 Future 来获得返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future 是一个接口，Future 提供了三种功能：</p><ul><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ul><p>同时还有一个 FutureTask 的类，FutureTask 的父类是 RunnableFuture，而 RunnableFuture 继承了 Runnbale 和 Futrue 这两个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><h2 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h2><p><strong>跟线程一样，Java 中的线程是对操作系统的线程概念的 wrapper，而 Java 中的同步问题也是操作系统的同步问题的 wrapper。</strong></p><h3 id="操作系统中的同步问题"><a href="#操作系统中的同步问题" class="headerlink" title="操作系统中的同步问题"></a>操作系统中的同步问题</h3><ul><li>进程同步<ul><li>信号量</li><li>管程（monitor）</li><li>消息传递</li></ul></li><li>线程同步<ul><li>临界区（Critical Section）</li><li>互斥量（Mutex）</li><li>信号量（Semaphore）</li><li>事件（Event）</li></ul></li></ul><h3 id="Java中线程同步问题"><a href="#Java中线程同步问题" class="headerlink" title="Java中线程同步问题"></a>Java中线程同步问题</h3><ul><li>synchronized<ul><li>Java中每个对象都有一个内置锁（修饰静态方法的时候，会锁住整个类）</li></ul></li><li>重入锁（java.util.concurrent），ReentrantLock<ul><li>实现是一个自旋锁，循环调用 CAS 操作来实现加锁</li></ul></li><li>ThreadLocal<ul><li>如果使用 ThreadLocal 管理变量，则每一个使用该变量的线程都获得该变量的副本</li></ul></li><li>使用阻塞队列实现线程同步<ul><li>java.util.concurrent 的 LinkedBlockingQueue<e></e></li></ul></li><li>使用原子变量实现线程同步<ul><li>java.util.concurrent.atomic，比如其中的 AtomicInteger</li></ul></li><li><p>wait() 和 notify()</p><ul><li><p>示例代码，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SyncStack ss = <span class="keyword">new</span> SyncStack();</span><br><span class="line"></span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(ss);</span><br><span class="line">        Consumer c = <span class="keyword">new</span> Consumer(ss);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        new Thread(p).start();</span></span><br><span class="line"><span class="comment">//        new Thread(p).start();</span></span><br><span class="line">        <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    Goods(<span class="keyword">int</span> id) &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Goods : "</span> + id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    Goods[] arrWT = <span class="keyword">new</span> Goods[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Goods wt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index == arrWT.length) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"满了"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        arrWT[index] = wt;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Goods <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"不够"</span>);</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">        index--;</span><br><span class="line">        <span class="keyword">return</span> arrWT[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    SyncStack ss = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Producer(SyncStack ss) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ss = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Goods goods = <span class="keyword">new</span> Goods(i);</span><br><span class="line">            ss.push(goods);</span><br><span class="line">            System.out.println(<span class="string">"生产了："</span> + goods);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">200</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    SyncStack ss = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    Consumer(SyncStack ss) &#123;</span><br><span class="line">        <span class="keyword">this</span>.ss = ss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            Goods goods = ss.pop();</span><br><span class="line">            System.out.println(<span class="string">"消费了: "</span> + goods);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="keyword">int</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Condition 是在 java 1.5 中才出现的，它用来替代传统的 Object 的 wait()、notify() 实现线程间的协作，相比使用 Object 的 wait()、notify()，使用 Condition 的await()、signal() 这种方式实现线程间协作更加安全和高效。</p></li></ul></li></ul><h3 id="ReenTrantLock-和-synchronized-的区别"><a href="#ReenTrantLock-和-synchronized-的区别" class="headerlink" title="ReenTrantLock 和 synchronized 的区别?"></a>ReenTrantLock 和 synchronized 的区别?</h3><ul><li>ReenTrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。</li><li>ReenTrantLock 提供了一个 Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像 synchronized 要么随机唤醒一个线程要么唤醒全部线程。</li><li>ReenTrantLock 提供了一种能够中断等待锁的线程的机制，通过 lock.lockInterruptibly() 来实现这个机制。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.jianshu.com/p/cf12d4244171" target="_blank" rel="noopener">Java并发之Runnable、Callable、Future、FutureTask</a></li><li><a href="https://www.cnblogs.com/Allen-rg/p/7172958.html" target="_blank" rel="noopener">进程同步的几种方式</a></li><li><a href="https://www.cnblogs.com/Allen-rg/p/7172970.html" target="_blank" rel="noopener">线程同步的几种方式</a></li><li><a href="https://blog.csdn.net/qq838642798/article/details/65441415" target="_blank" rel="noopener">ReenTrantLock可重入锁（和synchronized的区别）总结</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/a015b110387eb4a183fac7dc9526de6cd9e316b3/notes/Java%20%E5%B9%B6%E5%8F%91.md" target="_blank" rel="noopener">CS-Notes/notes/Java 并发.md</a></li><li><a href="https://blog.csdn.net/zqz_zqz/article/details/70246212" target="_blank" rel="noopener">java对象结构</a></li><li><a href="https://www.cnblogs.com/wewill/p/8058292.html" target="_blank" rel="noopener">锁原理：偏向锁、轻量锁、重量锁</a></li><li><a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">java 中的锁 – 偏向锁、轻量级锁、自旋锁、重量级锁</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="base" scheme="https://blog.pwxcoo.com/categories/base/"/>
    
    
      <category term="java" scheme="https://blog.pwxcoo.com/tags/java/"/>
    
      <category term="concurrent" scheme="https://blog.pwxcoo.com/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Redis和缓存</title>
    <link href="https://blog.pwxcoo.com/2018/09/06/%E6%B5%85%E8%B0%88Redis%E5%92%8C%E7%BC%93%E5%AD%98/"/>
    <id>https://blog.pwxcoo.com/2018/09/06/浅谈Redis和缓存/</id>
    <published>2018-09-06T04:00:54.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存的淘汰策略"><a href="#缓存的淘汰策略" class="headerlink" title="缓存的淘汰策略"></a>缓存的淘汰策略</h2><ul><li>FIFO(Fisrt In First Out)</li><li>LRU(Least Recently Used)</li></ul><h2 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h2><ul><li>浏览器</li><li>ISP</li><li>反向代理</li><li>服务器本地缓存</li><li>分布式缓存</li><li>数据库缓存</li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN(Content distribution network)。利用更靠近用户的服务器从而更快更可靠地将内容分发给用户。</p><blockquote><p>For that CDN will stores the data in multiple servers so once a data request arises from a visitor the CDN will take the data from the nearest server located near to the visitor and display it to the visitor.</p></blockquote><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>对不存在的数据进行请求，该请求会穿透缓存到达数据库。</p><ul><li>为不存在的数据缓存一个空数据</li><li>对这类请求过滤</li></ul><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>数据没 load 到缓存中，或者缓存在同一个时间大面积失效，或者缓存服务器宕机，导致大量请求都到达数据库。</p><ul><li>观察用户行为，合理设置缓存时间（或者给每个缓存加上一个随机值，避免集体失效）</li><li>分布式缓存，每个节点只缓存部分的数据，某个节点宕机的时候保证其他节点仍然可用</li><li>缓存预热，防止系统刚启动时还未将大量数据进行缓存而导致的雪崩  </li></ul><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2><ul><li>数据更新，立刻更新缓存</li><li>读取的时候判断是否是最新，不是再更新（惰性）</li></ul><p>保证缓存一致性需要付出很大的代价，缓存数据适合那些一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h2 id="分布式缓存的数据分布"><a href="#分布式缓存的数据分布" class="headerlink" title="分布式缓存的数据分布"></a>分布式缓存的数据分布</h2><ul><li>哈希分布</li><li>顺序分布</li></ul><h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>Distributed Hash Table(DHT)。</p><p>将哈希空间 $[0, 2^{n}-1]$ 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis(Remote Dictionary Server)。</p><p>Key-Value 类型的数据库，纯内存操作。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>STRING, 字符串 + 整型 + 浮点数<ul><li>字符串操作</li><li>数字加减</li></ul></li><li>LIST<ul><li>列表操作</li><li><strong>可以用来做消息队列</strong></li></ul></li><li>SET<ul><li>添加，删除，检查</li><li>交集，并集，差集</li><li><strong>可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</strong></li></ul></li><li>HASH<ul><li>添加，删除，检查</li><li>遍历</li><li><strong>可以用来做模拟 session</strong></li></ul></li><li>ZSET<ul><li>根据分值范围或者成员来获取元素</li><li>添加，删除，检查</li><li>计算排名</li><li><strong>可以做做排行榜</strong></li></ul></li></ul><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>定期删除 + 惰性删除。</p><p>在 redis.conf 中配置内存淘汰策略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure><ul><li>noeviction：throw error</li><li>allkeys-lru：LRU for all keys</li><li>allkeys-random: random for all keys</li><li>volatile-lru: LRU for expired keys</li><li>volatile-random: random for expired keys</li><li>volatile-ttl: remove the latest key for expired keys</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://redis.io/commands" target="_blank" rel="noopener">redis commands</a></li><li><a href="http://www.runoob.com/redis/redis-tutorial.html" target="_blank" rel="noopener">redis-tutorial</a></li><li><strong><a href="https://baijiahao.baidu.com/s?id=1594341157941741587&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">Redis的几道面试题</a></strong></li><li><a href="https://blog.csdn.net/hjm4702192/article/details/80518856" target="_blank" rel="noopener">Redis 总结精讲</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/a015b110387eb4a183fac7dc9526de6cd9e316b3/notes/Redis.md#%E8%B7%B3%E8%B7%83%E8%A1%A8" target="_blank" rel="noopener">CS-Notes/notes/Redis.md</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="base" scheme="https://blog.pwxcoo.com/categories/base/"/>
    
    
      <category term="cache" scheme="https://blog.pwxcoo.com/tags/cache/"/>
    
      <category term="redis" scheme="https://blog.pwxcoo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>约瑟夫环</title>
    <link href="https://blog.pwxcoo.com/2018/09/05/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    <id>https://blog.pwxcoo.com/2018/09/05/约瑟夫环/</id>
    <published>2018-09-05T09:13:59.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<p>约瑟夫环。感觉刚上大学的时候见过这个题目，昨天做笔试题的时候遇到了。。第一反应就是链表。。复杂度 $O(nm)$。不过数据也是水，也是过了。。</p><p>然后事后才知道这是约瑟夫环。用数学递推公式可以降到 $O(n)$。</p><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>推导的过程是一个逆向的过程，<strong>n 环约瑟夫环问题</strong>可以化解成 <strong>n - 1 环约瑟夫环问题</strong>。</p><p>模拟一下约瑟夫环的过程，下标从 0 开始：</p><ol><li>0, 1, … , m - 2, <del><strong>m - 1</strong></del>, <strong>m</strong>, …, n - 2, n - 1 (m - 1个被删去)</li><li>0, 1, … , m - 2, <strong>m</strong>, …, n - 2, n - 1 (从 m 开始重新计数)</li><li>n - m, n - m + 1, …, n - 2, <strong>0</strong>, …, n - 2 - m, n - 1 - m (然后把 0 重新提到最前面)</li><li><strong>0</strong>, 1, …, n - 2</li></ol><p>这就是 <strong>n 环约瑟夫环问题</strong> 变成了 <strong>n - 1 环约瑟夫环问题</strong> 的过程了。</p><p>可以发现在 <strong>n - 1 环约瑟夫环问题</strong> 中下标为 k 的元素，在 <strong>n 环约瑟夫环问题</strong> 中下标变成了 k + m。当然还要取一下余，变成了 (k + m) % n。</p><p>然后可以发现 <strong>在 n = 1 时，被删去的元素一定是下标为 0 的点</strong>。</p><p>然后推出两个结论，f(n) 表示  <strong>n 环约瑟夫环问题</strong> 中被删掉元素下标：</p><ul><li>f(n) = (f(n - 1) + m) % n</li><li>f(1) = 0</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> n, m, i, s = <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)  </span><br><span class="line">        s = (s + m) % i;  </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, s);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题</title>
    <link href="https://blog.pwxcoo.com/2018/09/03/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/09/03/01背包问题/</id>
    <published>2018-09-03T15:13:11.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>有 N 件物品和一个容量为 V 的背包。第i件物品的费用是 c[i]，价值是 w[i]。求解将哪些物品装入背包可使价值总和最大。</p><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>每次问题仅有一件，可以选择放或者不放。</p><p>然后变成一个 DP 问题，用一个 f[i][v] 表示前 i 件物品放入容量为 v 的背包获得的价值，状态转移方程：</p><p>$$f[i][v] = max(f[i-1][v], f[i-1][v - c[i]] + w[i])$$</p><p>时间复杂度 $O(NV)$，空间复杂度 $O(NV)$。</p><h3 id="空间优化"><a href="#空间优化" class="headerlink" title="空间优化"></a>空间优化</h3><p>空间可以优化成 $O(V)$。</p><p>因为计算完了 f[i] 时，只用到了 f[i-1]，f[i-2] 已经没用了，所以优化成一维数组（滚动数组），</p><p>$$f[v] = max(f[v], f[v-c[i]] + w[i])$$</p><h3 id="初始化的细节问题"><a href="#初始化的细节问题" class="headerlink" title="初始化的细节问题"></a>初始化的细节问题</h3><ul><li>不要求恰好装满，f[i] 全部初始化为 0。</li><li>要求恰好装好装满，除 f[0] 为 0，其余全部初始化为 $-\infty$。</li></ul><h3 id="一个常数优化"><a href="#一个常数优化" class="headerlink" title="一个常数优化"></a>一个常数优化</h3><p>此时的伪代码：</p><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>..n</span><br><span class="line">    <span class="keyword">for</span> v=V...c[i]</span><br><span class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li>每一层在 v &lt; c[i] 时，就不需要往下继续算了，因为肯定不放第 i 个物品了。</li><li>可以发现，在最后的一层遍历中中，只用求出 f[V] 就好了，不需要在遍历到前面了，倒数第一层只需要知道 f[V-c[n]] 的值就好了，也就是说倒数第二层只需要算到 f[V-c[n]]，就可以给倒数第一层用了，那继续推，倒数第三层只要算到 f[V-c[n]-c[n-1]] 就可以满足倒数第二层的需求了。</li></ul><p>优化后：</p><pre><code><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>..n</span><br><span class="line">    bound=max&#123;c[i], V-sum(c[i+<span class="number">1.</span>..n])&#125;</span><br><span class="line">    <span class="keyword">for</span> v=V...bound</span><br><span class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;</span><br></pre></td></tr></table></figure></code></pre><p>此优化在 V 非常大时比较有用。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>求出那些物品被放了，那些物品没被放？<ul><li>这种就要用二维数组来记录 dp 了，从右下角 f[N][V] 开始遍历，如果 f[i][v] == f[i-1][v] 说明没放，反之放了，然后一直遍历到左上角 f[0][0] 为止</li></ul></li><li>求出第 K 优的解？<ul><li>为 f[] 数组加一维，用来存放前 K 优解，每次更新的时候，按放入 i 个物品的前 K 优解和未放入 i 个物品的前 K 优解重新排序一波，然后将 K 优解放入 f[i]</li><li>相当于找出两个班的前 K 名，需要把两个班的前 K 名都拿出来</li></ul></li></ul><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>上次笔试题做到一个类似 01 背包的问题，然后没 A 掉。。我还记得我大二的时候还做过关于动态规划的 ppt，01 背包还是我当时的案例。。现在。。我恨。。</p><p>学一次，忘一次。。这次要记下来。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.kancloud.cn/kancloud/pack/70125" target="_blank" rel="noopener">第一讲 01背包问题 - 背包九讲</a></li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-04/hdu2546.cpp" target="_blank" rel="noopener">hdu2546</a> / 01背包</li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-04/hdu1171.cpp" target="_blank" rel="noopener">hdu1171</a> / 01背包</li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-05/hdu2602.cpp" target="_blank" rel="noopener">hdu2602</a> / 01背包</li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-09/2018-09-05/hdu2639.cpp" target="_blank" rel="noopener">hdu2639</a> / 01背包变形（求第 K 优解）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
      <category term="dp" scheme="https://blog.pwxcoo.com/tags/dp/"/>
    
  </entry>
  
  <entry>
    <title>浅谈HashMap和ConcurrentHashMap</title>
    <link href="https://blog.pwxcoo.com/2018/08/31/%E6%B5%85%E8%B0%88HashMap%E5%92%8CConcurrentHashMap/"/>
    <id>https://blog.pwxcoo.com/2018/08/31/浅谈HashMap和ConcurrentHashMap/</id>
    <published>2018-08-31T11:50:50.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<p>本篇的源码基于我自己电脑上的 <strong>jdk1.8.0_161</strong> 。</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ul><li>HashMap 在 jdk1.7 里是数组 + 链表，哈希冲突用拉链（头插法）解决。</li><li>HashMap 在 jdk1.8 里是数组 + 链表/红黑树，哈希冲突用拉链（头插法）解决（链表太长就用红黑树）。</li></ul><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment"> * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment"> * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for using a tree rather than list for a</span></span><br><span class="line"><span class="comment"> * bin.  Bins are converted to trees when adding an element to a</span></span><br><span class="line"><span class="comment"> * bin with at least this many nodes. The value must be greater</span></span><br><span class="line"><span class="comment"> * than 2 and should be at least 8 to mesh with assumptions in</span></span><br><span class="line"><span class="comment"> * tree removal about conversion back to plain bins upon</span></span><br><span class="line"><span class="comment"> * shrinkage.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></span><br><span class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></span><br><span class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment"> * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT_INITIAL_CAPACITY，默认 HashMap 的大小</li><li>MAXIMUM_CAPACITY，最大的 HashMap 的大小</li><li>DEFAULT_LOAD_FACTOR，默认的负载因子的大小</li><li>TREEIFY_THRESHOLD，将链表升级成红黑树的 threshold</li><li>UNTREEIFY_THRESHOLD，当 HashMap 删除元素后，红黑树退化成链表的 threshold</li><li>MIN_TREEIFY_CAPACITY，升级成红黑树的最小容量，表示 HashMap 达到这个容量之后，一定会升级成红黑树或者 resize。（但是我没在别人的博客里看到过这个。。我只是按照注释理解了一下。。这个东西下面没用到）</li><li><p>table[]，存放数据的数组，每个元素是一个内部类 Node</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>hash 就是 hash 值</li><li>key 是存放的 key 值</li><li>value 是存放的 value 值</li><li>next 是指向下一个 Node 的引用，生成链表时用的，<strong>如果升级成红黑树，会用 TreeNode（也是一个内部类） 代替 Node</strong></li></ul></li><li>size，HashMap 的 size</li><li>modCount，表示 HashMap 的 structural modified 次数（比如，添加删除元素，或者 resize 都算，但是如果仅仅是值的改变不算）。当迭代操作或者序列化操作时，操作前后需要比较 modCount 是否相等，不相等就 Fail-Fast，抛出 ConcurrentModificationException。</li><li>threshold，resize 的大小，等于 （capacity * load factor），达到 threshold 的时候就会扩容（会 rehash，复制数据等操作，比较消耗性能）</li><li>loadFactor，负载因子</li></ul><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断当前 table 是否未初始化，未初始化就初始化一波</li><li>根据 hash 值定位到具体的 bin，如果这个 bin 为空，直接新建一个 bin 放入这个 Node，<strong>然后返回</strong></li><li>判断 key 是否和当前结点的 key 相等，相等就直接替换 Node（或者 key 都为 null 的时候，HashMap 允许 key 为 null，顺便再插一句，HashMap 中 null 无法计算其 hash 值，默认都是放到下标为 0 的  上）</li><li>如果当前结点是 TreeNode 红黑树结点，就按红黑树的方法插入（具体就不展开了）</li><li>如果是链表，就遍历链表，找到相同的 key 的 Node 就可以直接替换 Node，如果没找到就 newNode()（这个方法会在对应的 bin 中插入 Node）</li><li>统一替换 Node（即 e 不为空）</li><li>modCount 自增</li><li>判断是否需要 resize</li></ul><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">* or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">* &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> (key==null ? k==null :</span></span><br><span class="line"><span class="comment">* key.equals(k))&#125;, then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise</span></span><br><span class="line"><span class="comment">* it returns &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;A return value of &#123;<span class="doctag">@code</span> null&#125; does not &lt;i&gt;necessarily&lt;/i&gt;</span></span><br><span class="line"><span class="comment">* indicate that the map contains no mapping for the key; it's also</span></span><br><span class="line"><span class="comment">* possible that the map explicitly maps the key to &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">* The &#123;<span class="doctag">@link</span> #containsKey containsKey&#125; operation may be used to</span></span><br><span class="line"><span class="comment">* distinguish these two cases.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断 table 是否未初始化，未初始化或者定位到的 bin 为空的话，直接<strong>返回 null</strong></li><li>判断第一个 Node/TreeNode 的值是否为查询的 key，是的话直接返回（always check first node），若不匹配就下一步</li><li>判断为 TreeNode，查找红黑树</li><li>判断链表，遍历链表查找</li></ul><h3 id="并发下会形成环形链表"><a href="#并发下会形成环形链表" class="headerlink" title="并发下会形成环形链表"></a>并发下会形成环形链表</h3><p>一个例子：</p><ol><li>刚开始，设 length 为 4，threshold 为 3，现在要扩容了<ul><li>0：</li><li>1：5 -&gt; 9 -&gt; 17</li><li>2：</li><li>3：</li></ul></li><li>thread1 执行扩容中，此时执行到 9 这个 Node：<ul><li>0：</li><li>1：<strong>9</strong> -&gt; 17</li><li>2:</li><li>3:</li><li>4:</li><li>5: 5</li><li>6：</li><li>7：</li></ul></li><li>thread2 执行完成：<ul><li>0：</li><li>1：17 -&gt; 9 </li><li>2:</li><li>3:</li><li>4:</li><li>5: 5</li><li>6：</li><li>7：</li></ul></li><li>thread1 继续执行，把 rehash 后的 9 插到 1 的 bin 上，头插插入<ul><li>0：</li><li>1：9 &lt;=&gt; 17</li><li>2:</li><li>3:</li><li>4:</li><li>5: 5</li><li>6：</li><li>7：</li></ul></li></ol><p>这样 9 和 17 成为了对方的 next，形成了环。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>其中的核心数据，如 value，以及链表都是 volatile 修饰的，保证了获取时的可见性。（可以防止出现环，get 时也不用加锁）</p><ul><li>ConcurrentHashMap 在 jdk1.7 中是由 Segment 数组（Segment 里存放 HashEntry 数组）构成的，Segment 继承自 ReentrantLock。<ul><li>put() <ul><li>尝试获取锁，失败说明和其他线程存在竞争，用 <code>canAndLockForPut()</code> 自旋获取锁<ul><li>尝试自旋获取锁</li><li>如果重试次数达到 <code>MAX_SCAN_RETRIES</code>，改为用阻塞锁获取</li></ul></li><li>定位到对应的 HashEntry</li><li>遍历，找到就替换</li><li>没找到就插入一个 HashEntry，并判断是否需要扩容</li><li>解锁</li></ul></li></ul></li><li>ConcurrentHashMap 在 jdk1.8 中加了红黑树并且做了一点结构上的调整，抛弃了 Segment 分段锁，采用了 CAS(Compare And Swap) + synchronized 来保证并发的安全性。</li></ul><h3 id="put-1"><a href="#put-1" class="headerlink" title="put()"></a>put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                    (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                            value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                        value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>计算出 hashCode</li><li>判断是否需要初始化</li><li>如果当前 key 定位的 Node 为空，尝试利用 CAS 写入，失败则自旋保证成功</li><li>如果 hashcode == MOVED，表示已经这个 Node 已经被移动过了（表示其他线程在进行扩容操作），helpTransfer() 是一个辅助方法</li><li>如果都不满足，即当前 key 存在，并且找到了，用 synchronized 锁写入数据</li><li>如果数量大于 TREEIFY_THRESHOLD，升级成红黑树</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>大后天回学校！</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！</a></li><li><a href="https://blog.csdn.net/fjse51/article/details/55260493" target="_blank" rel="noopener">jdk1.8中ConcurrentHashMap的实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="tech" scheme="https://blog.pwxcoo.com/categories/tech/"/>
    
    
      <category term="java" scheme="https://blog.pwxcoo.com/tags/java/"/>
    
      <category term="data structure" scheme="https://blog.pwxcoo.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>visual studio code配置C/C++环境</title>
    <link href="https://blog.pwxcoo.com/2018/08/28/visual-studio-code%E9%85%8D%E7%BD%AEC-C-%E7%8E%AF%E5%A2%83/"/>
    <id>https://blog.pwxcoo.com/2018/08/28/visual-studio-code配置C-C-环境/</id>
    <published>2018-08-28T14:51:56.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>目的是构建了简单 C/C++ 环境，用于小项目（比如算法题）。</p><h2 id="为什么用-visual-studio-code-写-C-C"><a href="#为什么用-visual-studio-code-写-C-C" class="headerlink" title="为什么用 visual studio code 写 C/C++"></a>为什么用 visual studio code 写 C/C++</h2><p>因为我是 visual studio code 的粉丝。这是我用过最快乐的编辑器了。</p><p>因为平时写 C/C++ 代码都是为了写算法题而写的，之前在 Windows 上用的 vs，感觉用了牛刀。。不过 vs 的调试功能给以前弱智的我有很大的帮助。。</p><p>后来在 Ubuntu 上都是用的 codeblocks 或者直接用 vim 开撸。。不知道为什么我真的对 vim 爱不起来，尝试放弃尝试放弃无数次，感觉只能是大概知道 vim 怎么用，但是作为日常编辑器感觉还是喜欢 vscode。。</p><p>第一次用 vscode 的时候，尝试过用 vscode 写 C/C++，但是那时候感觉体验有点糟糕。。后来貌似微软团队对 C/C++ 对了改进的，现在感觉还行，实在不行，就继续之前码完就 <code>g++ -Wall -std=c++11 main.cpp</code>。。。</p><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>下 C/C++ 这个扩展，Microsoft 官方出品的这个。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>下面所有的 vscode 命令用 <code>Ctrl + Alt + P</code> 打开 vscode 的工具窗口输入。</p><ul><li><code>C/CPP: Edit Configuration</code> =&gt; 生成一个 <code>c_cpp_properities.json</code> 。</li><li><p><code>Task: Configure Task Runner</code> =&gt; 选择 Other （当然如果要用 MSBuild 也可以，不过我自己用的是 g++，所以选了 Other =&gt; 生成 <code>task.json</code>。</p><p>  这里的 <code>task.json</code> 需要自己配置一下，我直接用的 vscode 的 snippet 功能的，贴一下我的 snippet（我的 json.json）：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // Place your snippets for JSON here. Each snippet is defined under a snippet name and has a prefix, body and </span><br><span class="line">    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:</span><br><span class="line">    // $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the </span><br><span class="line">    // same ids are connected.</span><br><span class="line">    // Example:</span><br><span class="line">    "cpp tasks": &#123;</span><br><span class="line">        "prefix": "cpptask",</span><br><span class="line">        "body": [</span><br><span class="line">        "&#123;",</span><br><span class="line">        "   \"label\": \"build\",",</span><br><span class="line">        "   \"command\": \"g++\",",</span><br><span class="line">        "   \"args\": [",</span><br><span class="line">        "       \"-std=c++11\",",</span><br><span class="line">        "      \"$1\",",</span><br><span class="line">        "      \"-o a.out\"",</span><br><span class="line">        "   ],",</span><br><span class="line">        "   \"type\": \"shell\"",</span><br><span class="line">        "&#125;,",</span><br><span class="line">        "&#123;",</span><br><span class="line">        "   \"label\": \"build-debug\",",</span><br><span class="line">        "   \"command\": \"g++\",",</span><br><span class="line">        "   \"args\": [",</span><br><span class="line">        "      \"-g\",",</span><br><span class="line">        "      \"-std=c++11\",",</span><br><span class="line">        "      \"$2\",",</span><br><span class="line">        "      \"-o a.out\"",</span><br><span class="line">        "   ],",</span><br><span class="line">        "   \"type\": \"shell\"",</span><br><span class="line">        <span class="string">"&#125;"</span></span><br><span class="line">        ],</span><br><span class="line">        "description": "Log output to console"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  用的 snippet 就减少重复的工作量了，直接输入 <code>cpptask</code> 就能生成一个 customize 的 snippet。然后自己写一下需要编译的 cpp 文件名就可以了，最后生成的 task.json 大概是这样的：</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=733558</span><br><span class="line">    // for the documentation about the tasks.json format</span><br><span class="line">    "version": "2.0.0",</span><br><span class="line">    "tasks": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"echo"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"echo Hello"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"label"</span>: <span class="string">"build"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"-std=c++11"</span>,</span><br><span class="line">            <span class="string">"./LRU/lru.cpp"</span>,</span><br><span class="line">            <span class="string">"-o a.out"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"shell"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="attr">"label"</span>: <span class="string">"build-debug"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [</span><br><span class="line">            <span class="string">"-g"</span>,</span><br><span class="line">            <span class="string">"-std=c++11"</span>,</span><br><span class="line">            <span class="string">"./LRU/lru.cpp"</span>,</span><br><span class="line">            <span class="string">"-o a.out"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"shell"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后就可以编译了，输入 <code>Tasks: Run Tasks</code> =&gt; <code>build</code> 然后编译完成，看到目标文件，执行就好了。</p></li><li><p>调试的功能（因为可视化的调试比终端里调试舒服多了，这也是我不想用 vim 的理由。。）</p><ul><li><code>Ctrl + Shift + D</code> 然后点那个齿轮，就自动生成了一个 <code>launch.json</code> 文件 </li><li>修改 <code>program</code> 里文件名</li><li>加上一个 <code>preLaunchTask</code> 的字段，值为 <code>build-debug</code>，表示调试前先编译。</li><li><p>最后的 <code>launch.json</code> 文件大概是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"(gdb) Launch"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/a.out"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"preLaunchTask"</span>: <span class="string">"build-debug"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后打断点，调试，就完事了。</p></li></ul></li></ul><hr><p>具体可以看 <a href="https://code.visualstudio.com/docs/languages/cpp" target="_blank" rel="noopener">C/C++ for VS Code (Preview)</a>，官方的文档更详细。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://code.visualstudio.com/docs/languages/cpp" target="_blank" rel="noopener">C/C++ for VS Code (Preview)</a></li><li><a href="https://blog.csdn.net/wzxlovesy/article/details/76708151" target="_blank" rel="noopener">VS Code 配置 C/C++ 环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="mome" scheme="https://blog.pwxcoo.com/categories/mome/"/>
    
    
      <category term="visual studio code" scheme="https://blog.pwxcoo.com/tags/visual-studio-code/"/>
    
      <category term="c++" scheme="https://blog.pwxcoo.com/tags/c/"/>
    
      <category term="c" scheme="https://blog.pwxcoo.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>浅谈数据库索引——一条sql语句引发的血案</title>
    <link href="https://blog.pwxcoo.com/2018/08/27/%E6%B5%85%E8%B0%88%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E2%80%94%E2%80%94%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/"/>
    <id>https://blog.pwxcoo.com/2018/08/27/浅谈数据库索引——一条sql语句引发的血案/</id>
    <published>2018-08-27T14:17:03.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天搞 <a href="https://github.com/pwxcoo/news-boom" target="_blank" rel="noopener">news-boom</a> 的时候，一条很奇怪的 sql 语句一直报错。</p><p>就是<a href="https://github.com/pwxcoo/news-boom/blob/master/src/main/java/com/pwxcoo/newsboom/dao/MessageDAO.java#L21" target="_blank" rel="noopener">这条</a></p><p>整理一下就是这这样子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    from_id, to_id, <span class="keyword">content</span>, has_read, conversation_id, created_date, <span class="keyword">count</span>(<span class="keyword">id</span>) <span class="keyword">as</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            *</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">            message</span><br><span class="line">        <span class="keyword">WHERE</span></span><br><span class="line">            from_id=<span class="number">1</span> <span class="keyword">OR</span> to_id=<span class="number">1</span></span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">            <span class="keyword">id</span> <span class="keyword">DESC</span></span><br><span class="line">    ) tt </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">        conversation_id</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">        <span class="keyword">id</span> <span class="keyword">DESC</span></span><br><span class="line">    <span class="keyword">LIMIT</span> </span><br><span class="line">        <span class="number">10</span>, <span class="number">10</span></span><br></pre></td></tr></table></figure><p>message 的 schema 是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`message`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`from_id`</span> <span class="built_in">INT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`to_id`</span> <span class="built_in">INT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`content`</span> <span class="built_in">TEXT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`created_date`</span> DATETIME <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`has_read`</span> <span class="built_in">INT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`conversation_id`</span> <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`conversation_index`</span> (<span class="string">`conversation_id`</span> <span class="keyword">ASC</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`created_date`</span> (<span class="string">`created_date`</span> <span class="keyword">ASC</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span>=utf8mb4;</span><br></pre></td></tr></table></figure><p>这条 sql 的目的是按 conversation 分类，然后把所有关于某个用户的每条 message 找出来。</p><p>然后这条 sql 就报错了。。报错信息大概就是这样子。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Err] 1055 - Expression #1 of ORDER BY clause is not in GROUP BY clause and contains nonaggregated column &apos;information_schema.PROFILING.SEQ&apos; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br></pre></td></tr></table></figure><p>然后就找到了官网的说法：</p><blockquote><p>SQL92 and earlier does not permit queries for which the select list, HAVING condition, or ORDER BY list refer to nonaggregated columns that are not named in the GROUP BY clause. </p></blockquote><p>我当时就蒙圈了，<code>nonaggregated</code> 又是什么。。</p><p>然后这样追本溯源。。居然补了很多数据库的知识。。然后就顺便记下来了。</p><h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><p>索引（Index）是用来高效获取数据的数据结构。大多的关系型数据库都是用的 B+ 树。复杂度是 $O=(n)$</p><h3 id="为什么不用哈希表？"><a href="#为什么不用哈希表？" class="headerlink" title="为什么不用哈希表？"></a>为什么不用哈希表？</h3><ul><li>范围查询中毫无用处</li><li>没法排序</li><li>不支持多表联合查询和最做匹配</li><li>在大量重复键值的情况，因为哈希碰撞，效率也是很低</li></ul><h3 id="为什么不用红黑树？"><a href="#为什么不用红黑树？" class="headerlink" title="为什么不用红黑树？"></a>为什么不用红黑树？</h3><p>数据库是存储在磁盘上的，最耗时间的是磁盘 I/O，要尽量减少磁盘的 I/O。</p><ul><li>红黑树中树的高度明显比 B/B+ 树要大</li><li>逻辑上很近的节点，物理上可能很远，磁盘寻道的时间消耗大。</li></ul><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p><img src="https://i.loli.net/2018/08/27/5b841d2d5f199.png" alt="/post-images/b-tree.png"></p><p>m 阶 B-Tree 满足一下条件：</p><ol><li>每个结点最多拥有 m 个子树，m-1 个 key</li><li>根结点上至少有 2 个子树</li><li>分支结点至少拥有 m/2 颗子树（除根结点和叶子结点外都是分支结点）</li><li>所有叶子结点都在同一层，每个结点可以有最多可以有 m-1 个 key，并且以升序排序</li></ol><p>B-Tree 的查找：</p><p><strong>从根结点二分查找，找到返回对应的 data，否则继续在相应区间的指针指向的几点递归进行查找</strong></p><p>对于 N 个数据，一个 m 阶的 B-Tree，查找的时间复杂度为 $O(log_{m}{N})$。</p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="https://i.loli.net/2018/08/27/5b841d7988e20.png" alt="/post-images/b+tree.png"></p><p>m 阶 B-Tree 满足一下条件：</p><ol><li>每个结点最多拥有 m 个子树，m 个 key</li><li>根结点和分支结点中不保存数据，只用于索引，所有数据都保存在叶子结点中</li><li>所有分支节点和根节点都同时存在于子节点中，在子节点元素中是最大或者最小的元素</li><li>叶子节点会包含所有的关键字，以及指向数据记录的指针，并且叶子节点本身是根据关键字的大小从小到大顺序链接</li></ol><p><strong>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。</strong>提高了区间访问的性能。</p><h3 id="为什么用B-B-树？"><a href="#为什么用B-B-树？" class="headerlink" title="为什么用B/B+树？"></a>为什么用B/B+树？</h3><ul><li>局部性原理（当一个数据被用到时，其附近的数据通常会被马上使用）。预读的长度通常为页的整数倍，许多操作系统中页的大小通常为 4 K。</li><li><p>每次新建结点，直接申请一个页的空间。m 的大小通常取决于 key 和 point 和 data 的大小。（由于 B+Tree 里内结点去掉了 data，可以拥有更大的出度）</p><p>  $$d_{max} = floor(\frac{pagesize}{keysize + datasize + pointsize})$$</p></li></ul><h2 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>使用的是 B+Tree 作为索引结构。</p><p>MyISAM 仅仅保存数据记录的地址，就是<strong>非聚族索引</strong>，就是最后查出来的结果，仍然是一个指针，并不是连续的。</p><p>MyISAM 主索引和辅助索引没有任何区别，只是主索引要求 key 是唯一的，辅助索引可以重复。</p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>也是 B+Tree 作为索引结构的。</p><p>InnoDB 的数据文件本身就是索引文件。叶结点中包含了完整的数据记录，这个叫<strong>聚族索引</strong>。</p><p>InnoDB 本身要按主键聚集，所以要求表必须有主键，如果没有显示指定，MySQL 会自动选择第一个可以唯一标识数据（Not NULL）作为主键，如果没有这种列，就会自动生成一个隐含字段作为主键，字段长度 6 个字节，类型为长整型。</p><p>InnoDB 中的辅助索引最后用的是主键作为 data 域，所以辅助索引需要检索两次：先找到主键索引，再用主键到主索引中获得记录。</p><p>所以不建议用过长的字段作为主键，这样会让辅助索引变得很大，而且非单调的主键在插入时，会导致 B+Tree 频繁地分裂。用自增主键其实是一个非常合适的选择。</p><h2 id="MySQL-Handling-of-GROUP-BY"><a href="#MySQL-Handling-of-GROUP-BY" class="headerlink" title="MySQL Handling of GROUP BY"></a>MySQL Handling of GROUP BY</h2><p>上面扯远了。。跟最后的 Solution 没有关系。。只是 <code>aggregate</code> 这个单词重复出现了，我以为是同一个 <code>aggregate</code> 。。</p><p>最后文档里的意思是说在用了 <code>GROUP BY</code> 之后，是不能 select 非 <code>aggregate</code> 的 column 的，什么是 <code>aggregate</code> 呢，看一下 <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-handling.html" target="_blank" rel="noopener">Aggregate (GROUP BY) Function Descriptions</a> 就知道了。</p><p>另外在文档中提到，如果是 <code>functionally dependent on GROUP BY columns</code> 的 column，也是可以的。</p><blockquote><p>SQL99 and later permits such nonaggregates per optional feature T301 if they are functionally dependent on GROUP BY columns: If such a relationship exists between name and custid, the query is legal. This would be the case, for example, were custid a primary key of customers.</p></blockquote><p>文档里有个例子：</p><blockquote><p>This query might be invalid with ONLY_FULL_GROUP_BY enabled because the nonaggregated address column in the select list is not named in the GROUP BY clause:</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, address, <span class="keyword">MAX</span>(age) <span class="keyword">FROM</span> t <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure><blockquote><p>The query is valid if name is a primary key of t or is a unique NOT NULL column. In such cases, MySQL recognizes that the selected column is functionally dependent on a grouping column. For example, if name is a primary key, its value determines the value of address because each group has only one value of the primary key and thus only one row. As a result, there is no randomness in the choice of address value in a group and no need to reject the query.</p></blockquote><p>总之就是 GROUP BY 没表达清楚意思，就不能用了，以前还能随便给你返回一个结果，现在 MySQL 改版了，遵守 <code>SQL92</code> 和更高版本的规范了，不能这么乱写了。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>如果就是想这样支持之前版本的话，可以修改 MySQL 配置。</p><ul><li><code>select @@global.sql_mode</code></li><li>去掉ONLY_FULL_GROUP_BY，重新设置值。<code>set @@global.sql_mode =&#39;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#39;;</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最近家里天气很鸡掰。。一会太阳，一会下雨。。简直有毛病。。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-handling.html" target="_blank" rel="noopener">12.19.3 MySQL Handling of GROUP BY</a></li><li><a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html" target="_blank" rel="noopener">12.19.1 Aggregate (GROUP BY) Function Descriptions</a></li><li><a href="https://www.cnblogs.com/wyy123/p/6269875.html" target="_blank" rel="noopener">MySQL的聚集索引和非聚集索引 - 仲夏的落叶</a></li><li><a href="https://www.cnblogs.com/duzhentong/p/8639223.html" target="_blank" rel="noopener">MySQL聚集索引和非聚集索引 - In_new</a></li><li><a href="https://www.cnblogs.com/zhi-leaf/p/5998820.html" target="_blank" rel="noopener">MYSQL5.7版本sql_mode=only_full_group_by问题</a></li><li><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="database" scheme="https://blog.pwxcoo.com/categories/database/"/>
    
    
      <category term="mysql" scheme="https://blog.pwxcoo.com/tags/mysql/"/>
    
      <category term="database" scheme="https://blog.pwxcoo.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>浅谈哈希冲突</title>
    <link href="https://blog.pwxcoo.com/2018/08/06/%E6%B5%85%E8%B0%88%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81/"/>
    <id>https://blog.pwxcoo.com/2018/08/06/浅谈哈希冲突/</id>
    <published>2018-08-06T02:16:14.000Z</published>
    <updated>2018-11-16T05:22:47.951Z</updated>
    
    <content type="html"><![CDATA[<p>理想的哈希函数是不会有冲突的，但是实际的哈希函数，不可能完全避免冲突。</p><p>一般有 4 中解决办法：</p><ul><li>开放定址法<ul><li>线性探测</li><li>二次探测</li><li>伪随机探测</li></ul></li><li>再哈希</li><li>链地址</li><li>建立公共溢出区</li></ul><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>$$H_{i} = (H(key) + d_{i}) \% m, \space \space \space \space \space i=1,2,…,n$$</p><p>其中 H（key）为哈希函数，m 为表长，di称为增量序列。</p><h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p>$d_{i} = 1, 2, …, m - 1$</p><h3 id="二次探测"><a href="#二次探测" class="headerlink" title="二次探测"></a>二次探测</h3><p>$d_{i} = 1^{2}, -1^{2}, 2^{2}, -2^{2},…, k^{2}, -k^{2}  (k^{2} &lt; m)$</p><h3 id="伪随机探测"><a href="#伪随机探测" class="headerlink" title="伪随机探测"></a>伪随机探测</h3><p>$d_{i}=$ 伪随机数序列</p><h2 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h2><p>$$H_{i} = H_{i}(key), \space \space \space \space \space  i=1，2，…，k$$</p><p>当 $H_{1}(key)$ 发生冲突时，在计算 $H_{2}(key)$，… 直到冲突不再产生。</p><h2 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h2><p>将所有哈希地址相同的元素，构成一个同义词链的链表。</p><h2 id="建立公共溢出区"><a href="#建立公共溢出区" class="headerlink" title="建立公共溢出区"></a>建立公共溢出区</h2><p>将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p><h2 id="开放探测-vs-链地址法"><a href="#开放探测-vs-链地址法" class="headerlink" title="开放探测 vs 链地址法"></a>开放探测 vs 链地址法</h2><p>开放探测的缺点：</p><ul><li>需要一个处理溢出的程序</li><li>删除工作，为什么保证同义词链的话，不能直接把删除节点置为空（因为会影响到该节点后面的节点），只能标上一个删除记号</li><li>容易产生堆积</li></ul><p>链地址的优点：</p><ul><li>无堆积</li><li>节点空间动态申请，适合无法确定表长的情况</li><li>删除简单</li></ul><p>链地址的缺点：</p><ul><li>指针需要额外的空间 </li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/wuchaodzxx/p/7396599.html" target="_blank" rel="noopener">解决hash冲突的三个方法</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="data structure" scheme="https://blog.pwxcoo.com/categories/data-structure/"/>
    
    
      <category term="data structure" scheme="https://blog.pwxcoo.com/tags/data-structure/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://blog.pwxcoo.com/2018/08/02/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://blog.pwxcoo.com/2018/08/02/快速幂/</id>
    <published>2018-08-02T15:44:07.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>因为昨天突然做了一个快速幂，然后因为之前一直遇到比较少，所以也没在意。。这次正好看了一下。</p><p>二分幂，快速幂，矩阵快速幂在计算大指数次方的时候比较高效，因为相当于二分了，就从传统求次方的 O(n) 变成了 O(logn) 。</p><p>其实二分幂就是快速幂，二分幂是快速幂递归写法，而通常意义上说的快速幂指的是非递归写法，然后矩阵快速幂就是用矩阵乘法替换一下就好了。</p><h2 id="二分幂（快速幂的递归写法）"><a href="#二分幂（快速幂的递归写法）" class="headerlink" title="二分幂（快速幂的递归写法）"></a>二分幂（快速幂的递归写法）</h2><p>就是把求解 $a^{n}$ 的问题变成求解 $a^{\frac{n}{2}} \cdot a^{\frac{n}{2}}$ 或者 $a^{\frac{n}{2}} \cdot a^{\frac{n}{2}} \cdot a$ （根据 n 的奇偶确定转话成哪个）的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> base,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> base;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="built_in">pow</span>(base,n/<span class="number">2</span>);</span><br><span class="line">    ans *= ans;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        ans *= base;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p>就是把写法写成非递归的，可以用位运算，其实不用也没关系，可能是写起来比较好看吧。</p><p>举个例子，相当于<br>$$<br>A=a^{6}=a^{110}=(a^{2^{2}} \cdot 1) \cdot (a^{2^{1}} \cdot 1) \cdot (a^{2^{0}} \cdot 0)<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b )</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> base = a;</span><br><span class="line">    <span class="keyword">while</span> ( b != <span class="number">0</span> ) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            r *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= base; </span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h3><p>突然联想到快速乘，顺便提一下。。。因为 $a\cdot b$ 有可能在取模之前就溢出，所以可以这种类似快速幂的办法来解决，借助二进制的思想。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastMultiplication</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a,<span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            b--;</span><br><span class="line">            ans = ans + a;</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            b /= <span class="number">2</span>;</span><br><span class="line">            a = a + a;</span><br><span class="line">            a %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>就是把乘法换成矩阵的乘法。</p><p>矩阵快速幂可以用在很多递推式的中，比如 $f(n)=a\cdot f(n-1) + b\cdot f(n-2)$ ，可以用矩阵运算快速求出若干项的结果。</p><p>最简单就是用在 Fibonacci 中了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> edges[MAXN][MAXN];</span><br><span class="line">    Matrix() &#123;&#125;</span><br><span class="line">    Matrix <span class="keyword">operator</span>*(Matrix <span class="keyword">const</span> &amp;b)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        Matrix res;</span><br><span class="line">        <span class="built_in">memset</span>(res.edges, <span class="number">0</span>, <span class="keyword">sizeof</span>(res));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; MAXN; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; MAXN; k++)</span><br><span class="line">                    res.edges[i][j] = (res.edges[i][j] + <span class="keyword">this</span>-&gt;edges[i][k] * b.edges[k][j]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fastpow</span><span class="params">(Matrix base, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Matrix res;</span><br><span class="line">    <span class="built_in">memset</span>(res.edges, <span class="number">0</span>, <span class="keyword">sizeof</span>(res.edges));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAXN; i++)</span><br><span class="line">        res.edges[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * base;</span><br><span class="line">        base = base * base;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-08/2018-08-01/kickstart-2018-C-C.cpp" target="_blank" rel="noopener">kickstart-2018-RoundC-C</a> 快速幂 + 求需要取模的等比数列和的类快速幂算法</li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-08/2018-08-01/poj3070.cpp" target="_blank" rel="noopener">poj3070</a> 矩阵快速幂</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>图的拓扑排序问题</title>
    <link href="https://blog.pwxcoo.com/2018/07/24/%E5%9B%BE%E7%9A%84%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.pwxcoo.com/2018/07/24/图的拓扑排序问题/</id>
    <published>2018-07-24T15:51:34.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写算法题了。。</p><p>遇到一个”求图中存在环的问题“的时候，磕磕绊绊了好久。。</p><h2 id="邻接表和邻接矩阵"><a href="#邻接表和邻接矩阵" class="headerlink" title="邻接表和邻接矩阵"></a>邻接表和邻接矩阵</h2><p>就是两个两种用来存储图数据结构的方法。</p><ul><li>邻接表。一个数组，每个 index 是一个链表，每个链表就是连接着的 node</li><li>邻接矩阵。用一个矩阵来存储 edge，在图比较稀疏的时候比较浪费空间</li></ul><h2 id="求图的时候存在环"><a href="#求图的时候存在环" class="headerlink" title="求图的时候存在环"></a>求图的时候存在环</h2><p>因为在这个问题里，有向图和无向图没什么卵区别，所以也不做区分了。</p><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><p>直接上 dfs，遇到遍历过的，直接判定存在环。</p><p>因为担心<strong>环的重复计算</strong>。</p><p><img src="https://i.loli.net/2018/07/25/5b574e888c55b.png" alt="graph-cycle-dfs"></p><p>就像这样，如果 1-&gt;2-&gt;3 遍历了，发现 3-&gt;1，于是判定了一波环，继续 1-&gt;3，又发现了一波环，重复计算了一波（但是我感觉对判断是否存在环这个问题里没有问题的，拓展开来可能存在一些问题）。</p><p>所以不仅设置一个 <code>visited[]</code>，还要设置一个 <code>onpath[]</code> 来标记，已经遍历完这个 node，还是正在遍历中。一个很形象的比喻就是，初始化白色结点，遍历中灰色，遍历完了黑色。</p><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><p>把入度为 0 的点（无向图就是入度为 1）加入队列，然后取出，把该点删去，同时删去以该点为起始点的边，如此写一个 BFS。</p><p>缺点是不能输出环。因为并不是剩余的所有点都是环的顶点。</p><p><img src="https://i.loli.net/2018/07/25/5b5751ac34dbe.png" alt="graph-cycle-bfs"></p><p>图中 4 就不是环的顶点。</p><hr><p>输入环，想拓扑排序一波，就用 DFS。加一个 <code>pre[]</code> 就可以了。</p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><p>因为最短路是顺便写到的。所以随便记一下。</p><p>最简单朴素的最短路。</p><p>思路反正就是起始点入队列，然后不断更新 <code>dis[]</code>。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.cnblogs.com/TenosDoIt/p/3644225.html" target="_blank" rel="noopener">判断一个图是否有环 - JustDoIT</a></li><li><a href="https://github.com/pwxcoo/ac-game/blob/master/2018-07/2018-07-24/kickstart-2018-C-A.cpp" target="_blank" rel="noopener">kickstart-2018-RoundC-A</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="https://blog.pwxcoo.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Manage a Series of SSH Keys</title>
    <link href="https://blog.pwxcoo.com/2018/07/15/Manage%20a%20Series%20of%20SSH%20Keys/"/>
    <id>https://blog.pwxcoo.com/2018/07/15/Manage a Series of SSH Keys/</id>
    <published>2018-07-15T14:18:47.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>因为 <code>ssh</code> 用起来太爽了，很多的时候生成了一堆 <code>ssh</code> 私钥，如何在一台设备上管理多个 <code>ssh</code> 私钥。</p><p>起因是想在公司电脑上管理两个 git account。一个公司的，一个自己的，然后配置了半天。。。主要还是因为 CSDN 那几篇博客有点坑（说 config 里 Host 是可以随便设置，却没提到 Host 是 ssh 开连接找路由的入口。。）。。每次都 authentication 失败。。不过后来在 Stackoverflow 上找到原因了。。感觉 zz。</p><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><p>删除 global config 设置:(不过好像不删也没什么关系？因为讲道理 local config 是可以覆盖 global config 的)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">$ git config --global --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure></p><p>然后给每个 repository 设置自己的 local config:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.email <span class="string">"example@email.com"</span></span><br><span class="line">git config user.name <span class="string">"your_name"</span></span><br></pre></td></tr></table></figure></p><h2 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h2><p>生成 <code>ssh</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"example@email.com"</span></span><br></pre></td></tr></table></figure></p><p>会提示要不要覆盖原来的 <code>id_rsa</code>，当然是不要，重新开一个名字，比如 <code>id_rsa_github</code> 这样子。</p><p>然后在对应的 git server 上加上自己的公钥。</p><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>在 <code>~/.ssh/</code> 目录下新建一个 config 文件，然后写配置文件。</p><p>很多博客没提到 Host 是路由，而是说 HostName 要写上目标网站，于是我一开始就以为 ssh 是通过 HostName 找 server 的。。其实 Host 是 ssh 找连接的路由，两个都是 ssh 连接时要用到的。</p><p>我的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa_github</span><br><span class="line"></span><br><span class="line">Host vs-ssh.visualstudio.com</span><br><span class="line">HostName vs-ssh.visualstudio.com</span><br><span class="line">User t-xiwu</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>用 <code>ssh</code> 连一下就知道有没有成功了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>具体信息可以加个 <code>v</code> 的选项就可以了，就是 <code>verbose</code> ，可以用来调试，看看哪里出错了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -Tv git@github.com</span><br></pre></td></tr></table></figure></p><p>更具体的可以用 <code>vvv</code>，更详细的信息。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -vvv git@github.com</span><br></pre></td></tr></table></figure></p><p>我最后就是这样子，然后带着错误信息在 Stackoverflow 找到了 Solution。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="record" scheme="https://blog.pwxcoo.com/categories/record/"/>
    
    
      <category term="ssh" scheme="https://blog.pwxcoo.com/tags/ssh/"/>
    
      <category term="git" scheme="https://blog.pwxcoo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Internal Compiler Error</title>
    <link href="https://blog.pwxcoo.com/2018/07/10/Internal%20Compiler%20Error/"/>
    <id>https://blog.pwxcoo.com/2018/07/10/Internal Compiler Error/</id>
    <published>2018-07-10T14:11:04.000Z</published>
    <updated>2018-11-16T05:22:47.947Z</updated>
    
    <content type="html"><![CDATA[<p>There is nothing to say here.</p><!-- ## 汇编和寒假转眼之间，在微软 3 个月实习已经过了一半了，今年上半年可以说是很纠结的一年了，寒假的时候了解了一下汇编和编译原理（因为没选到这门课），看了 Stanford 的那节 CS143 Compiler 那节课，最后的 assignment 是做一个 Cool 语言的编译器。Cool 是 Stanford 的老师为了这门课自己设计的一个面向对象的程序语言。后来折腾了很久，因为 MIPS 汇编语言的资料不是很充足，加上自己的基础并不好和寒假时间也不多，最后没能完成这个 assignment，算是比较遗憾的一件事吧。希望如果以后有空，能重新捡起这个来。好处是学了汇编和编译原理的一些知识后，对编程语言有了全新的理解，看到一个 syntax，总想把它 parse 成汇编代码，让我对高级语言最后怎么解析成汇编语言有了更 detail 的认知。同时对寄存器，内存分配，程序的一些概念有了更为深刻的一些理解。不过我学校把这个设为选修课，并且还不是我专业的专选课。。。（虽然就算是专选课也是水得不行，感觉还可能坑的一匹。。不如不是好了。。）----## 春招和考研开学前给阿里投了简历，投的是 Java 开发实习生。我也是惊了，面了才知道自己这么菜，其实自己对于 Java，真的只是会 syntax 而已。。果然面了两轮就挂了。。太菜了，不挂我挂谁。。还给网易游戏投了一份，石沉大海，然后在我入职微软几天后给我发了感谢信。。春找没投几家，阿里最早面的，也是最早挂的。挂了之后感觉自己实在太菜，根本没机会。。BAT 也就投了一家杭州的 A 。剩下的也不敢投了。。阿里挂了之后开始准备考研，在考研教室学习了一个多月，后来收到微软的 offer，放弃了考研。。备考了一个多月的考研之后对研究生还是很向往的，因为学生有很多自己的 free time 可以支配，同时我也更向往一个高级学府。微软的面试体验还是很棒的。我还记得我是今年 3 月 31 号做的微软笔试题，去年微软有个预苗计划，当时也是 3 月 31 号，我参加了，可是去年太菜了，去年我还记得那天去武汉玩，到了之后用老二电脑电脑做的笔试题，直接爆零。。gg思密达。。今年过了笔试之后，因为我邮箱填错了，没收到 onsite 的面试邮件。。后来 hr 打电话来找到我让我去 onsite 面试，可以说是很感动了。微软的面试题目没什么印象了，就是一直做题，还做了一道智力题，比较有意思，所以印象深刻。其实我感觉我 onsite 面试表现还是不错的，感觉比自己电话面试的时候发挥好一些。。然后微软就是做算法题，感觉自己比较 fit 这个面试模式吧。在微软实习也遇到很多研究生和留学生，大部分都是研究生和留学生吧。也是很羡慕别人 3 年研究生生活或者留学生生活的。## 杂还记得面试的时候，面试官问我对什么感兴趣，我说我对什么都挺感兴趣的。其实我真的对什么都很感兴趣。无论是前端，后端还是算法。 -->]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="nuisance" scheme="https://blog.pwxcoo.com/categories/nuisance/"/>
    
    
      <category term="essay" scheme="https://blog.pwxcoo.com/tags/essay/"/>
    
  </entry>
  
</feed>
